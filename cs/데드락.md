Dead lock(교착 상태)

-두개 이상의 프로세스/쓰레드가 서로가 가진 리소스를 기다리는 상태

  

조건

1. mutual exclusion(상호배제)
    - 리소스를 공유해서 사용할 수 없다
    - 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구한다.
2. hold and wait(점유대기) -
    - 프/쓰가 이미 하나 이상의 리소스를 취득(hold)한 상태에서 다른 프/쓰가 사용하고 있는 리소스를 추가로 기다린다(wait)
    - 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다.
3. no preemption(비선점)
    - 리소스 반환(release)은 오직 그 리소스를 취득한 프/쓰만 할 수 있다
    - 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없다.
4. circular wait(순환 대기)
    - 프/쓰가 순환 형태로 서로의 리소스를 기다린다
    - 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다.

  

이 조건 중에서 한 가지라도 만족하지 않으면 교착 상태는 발생하지 않는다. 이 중 순환대기 조건은 점유대기 조건과 비선점 조건을 만족해야 성립하는 조건이므로, 위 4가지 조건은 서로 완전히 독립적인 것은 아니다.

  

### **교착 상태의 예방**

- 상호배제 조건의 제거

교착 상태는 두 개 이상의 프로세스가 공유 불가능한 자원을 사용하니 발생하는 것이므로 공유 불가능한, 즉사 상호 배제 조건을 제거하면 교착 상태를 해결할 수 있다.

- 점유와 대기 조건의 제거

한 프로세스에 수행되기 전에 모든 자원을 할당시키고 나서 점유하지 않을 때에는 다른 프로세스가 자원을 요구하도록 하는 방법이다. 자원 과다 사용으로 인한 효율성, 프로세스가 요구하는 자원을 파악하는 데에 대한 비용, 자원에 대한 내용을 저장 및 복원하기 위한 비용, 기아상태, 무한 대기 등의 문제점이 있다.

- 비선점 조건의 제거

비선점 프로세스에 대해 선점 가능한 프로토콜을 만들어 준다.

- 순환 대기 조건의 제거

자원 유형에 따라 순서를 매긴다.

이 교착 상태의 해결 방법들은 자원 사용의 효율성이 떨어지고 비용이 많이 드는 문제점이 있다.

### **교착 상태의 회피**

자원이 어떻게 요청될지에 대한 추가정보를 제공하도록 요구하는 것으로 시스템에 circular wait가 발생하지 않도록 자원 할당 상태를 검사한다.

교착 상태 회피하기 위한 알고리즘으로 크게 두가지가 있다.

1) 자원 할당 그래프 알고리즘 (Resource Allocation Graph Algorithm)2) 은행원 알고리즘 (Banker’s algorithm)