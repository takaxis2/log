## 1. 첫 프로세스 생성 (init 또는 systemd)

- 컴퓨터가 부팅되면 **커널(kernel)** 이 메모리에 올라오고, 가장 먼저 **init 프로세스**(또는 현대 리눅스에서는 `systemd`)가 생성.
    
- 이 프로세스는 **PID 1**을 가지며, 이후 사용자 프로세스나 데몬 프로세스들을 생성하는 **부모 프로세스** 역할.
    
- 이때 커널은 다음과 같은 정보를 담은 **PCB(Process Control Block)** 를 생성해\:
    
    - 프로세스 ID (PID)
        
    - 프로그램 카운터 (PC)
        
    - 레지스터 상태
        
    - 프로세스 상태 (준비, 실행, 대기 등)
        
    - 메모리 정보 (코드, 데이터, 스택 영역)
        
    - 파일 디스크립터 등
        

## 2. 이후 프로세스 생성 (fork, exec)

- `init` 또는 다른 프로세스는 **fork()** 시스템 콜을 통해 **자식 프로세스**를 생성.
    
- `fork()`는 부모의 PCB를 복사하여 자식 프로세스를 만들고, 이 자식은 새로운 PID를 가짐.
    
- 이후 `exec()`를 호출하면 자식 프로세스의 메모리 공간을 새로운 프로그램으로 덮어씀.
    
- 이 과정에서도 새로운 PCB가 생성되며, 커널은 이를 통해 각 프로세스를 관리함.
    

## 3. PCB와 Context Switching

- **Context Switching(문맥 교환)** 은 CPU가 한 프로세스에서 다른 프로세스로 전환할 때 발생.
    
- 이때 중요한 것이 **PCB**야. :
    
    - 현재 실행 중인 프로세스의 **레지스터 값, 프로그램 카운터, 상태** 등을 PCB에 저장,
        
    - 다음에 실행할 프로세스의 PCB에서 이 정보를 **복원**해야 하기 때문.
        
- 문맥 교환 과정:
    
    1. 현재 프로세스의 상태를 PCB에 저장
        
    2. 스케줄러가 다음 실행할 프로세스를 선택
        
    3. 선택된 프로세스의 PCB에서 상태를 복원
        
    4. CPU가 해당 프로세스를 실행

```
[부팅]
  ↓
[init(systemd) 생성 → PCB 생성]
  ↓
[다른 프로세스 fork → PCB 복사]
  ↓
[exec로 새 프로그램 실행 → PCB 갱신]
  ↓
[여러 프로세스 실행 중 → Context Switching 발생]
  ↓
[PCB를 통해 상태 저장/복원]

```