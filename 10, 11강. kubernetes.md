
쿠버네티스는 컨테이너화된 애플리케이션의 배포, 확장 및 관리를 자동화하는 오픈소스 플랫폼입니다. 구글의 내부 시스템인 'Borg'에 영향을 받아 2014년에 처음 발표되었으며, 이후 리눅스 재단과 구글이 설립한 Cloud Native Computing Foundation(CNCF)에 기부되어 클라우드 네이티브 기술의 핵심으로 자리 잡았습니다. 현재 모든 주요 클라우드 서비스 제공업체(CSP)가 자사 플랫폼에 쿠버네티스 서비스를 내재화하여 사실상의 표준으로 통용됩니다.

쿠버네티스의 핵심은 사용자가 정의한 '의도된 상태(Desired State)'를 유지하는 선언적(Declarative) 접근 방식에 있습니다. 사용자는 YAML 파일을 통해 애플리케이션의 구성과 필요한 리소스(Pod, Service, Deployment 등)를 정의하며, 쿠버네티스는 현재 상태가 이 정의와 일치하도록 클러스터를 자동으로 관리합니다.

주요 특징으로는 실패한 컨테이너를 자동으로 복구하는 **자가 치유(Self-healing)**, CPU 및 메모리 사용량에 따라 애플리케이션을 확장하는 **수평적 확장(Horizontal scaling)**, 그리고 서비스 중단 없이 업데이트를 적용하고 문제가 발생하면 자동으로 이전 버전으로 되돌리는 **자동화된 롤아웃 및 롤백(Automated rollouts and rollbacks)** 기능 등이 있습니다. 이러한 강력한 기능들을 통해 쿠버네티스는 마이크로서비스, 서버리스, CI/CD 파이프라인 등 현대적인 클라우드 네이티브 아키텍처의 기반을 제공합니다.

--------------------------------------------------------------------------------

## 1. 쿠버네티스 개요

### 1.1. 정의와 역할

쿠버네티스는 컨테이너를 쉽고 빠르게 배포 및 확장하고, 관련 관리를 자동화해주는 오픈소스 플랫폼입니다. 이는 단순한 컨테이너 플랫폼을 넘어 마이크로서비스 및 클라우드 플랫폼을 지향하며, 컨테이너로 구성된 시스템을 손쉽게 담고 관리할 수 있는 '그릇' 역할을 수행합니다.

공식 웹사이트에서는 쿠버네티스를 다음과 같이 정의합니다:

"Kubernetes is an open-source system for automating deployment, scaling, and management of containerized applications."

서버리스, CI/CD, 머신러닝 등 다양한 최신 기술 스택이 쿠버네티스 플랫폼 위에서 동작하며 생태계를 확장하고 있습니다.

### 1.2. 기원 및 발전

- **기원**: 구글의 내부 대규모 클러스터 관리 시스템인 'Borg'의 영향을 받아 개발되었습니다.
- **발표**: 2014년 구글에 의해 처음 세상에 공개되었습니다.
- **정식 출시**: 2015년 7월 21일, 버전 1.0이 출시되었습니다.
- **표준화**: 구글은 리눅스 재단과 함께 **Cloud Native Computing Foundation (CNCF)**를 설립하고, 쿠버네티스를 핵심 기술(Seed Technology)로 기부하여 클라우드 네이티브 컴퓨팅의 표준화를 주도했습니다.

## 2. 핵심 기능 및 아키텍처

### 2.1. 주요 오케스트레이션 기능

쿠버네티스는 다음과 같은 핵심 컨테이너 오케스트레이션 기능을 제공합니다.

- **컨테이너 자동 배치 및 복제**: 리소스 요구사항에 맞춰 컨테이너를 최적의 노드에 자동으로 배치하고, 정의된 수만큼 복제하여 유지합니다.
- **컨테이너 그룹에 대한 로드밸런싱**: 여러 컨테이너에 걸쳐 네트워크 트래픽을 분산시킵니다.
- **컨테이너 장애 복구**: 작동을 멈추거나 헬스 체크에 실패한 컨테이너를 자동으로 재시작하거나 교체합니다.
- **클러스터 외부에서 서비스 노출**: 내부에서 실행 중인 애플리케이션을 외부에서도 접근할 수 있도록 경로를 제공합니다.
- **컨테이너 확장 및 축소**: 부하량에 따라 컨테이너의 수를 동적으로 조절합니다.
- **컨테이너 서비스 간 인터페이스를 통한 연결**: 서비스 디스커버리 기능을 통해 서비스 간의 통신을 용이하게 합니다.

### 2.2. 상세 기능 분석

쿠버네티스의 주요 기능은 다음과 같이 요약할 수 있습니다.

|   |   |
|---|---|
|구분|설명|
|**Automatic binpacking**|각 컨테이너가 필요로 하는 CPU와 메모리(RAM)를 요청받아, 쿠버네티스가 컨테이너를 최적의 노드에 맞추어 자동으로 스케줄링합니다.|
|**Self-healing**|실패한 노드의 컨테이너를 자동으로 교체 및 재스케줄링하며, 헬스 체크에 응답하지 않는 컨테이너를 정해진 규칙에 따라 재시작합니다.|
|**Horizontal scaling**|CPU 및 메모리와 같은 리소스 사용량을 기반으로 애플리케이션을 자동으로 확장할 수 있으며, 커스텀 메트릭을 기반으로 하는 동적 스케일링도 지원합니다.|
|**Service discovery & load balancing**|애플리케이션 수정 없이 서비스 디스커버리 매커니즘을 제공합니다. 쿠버네티스는 내부적으로 Pod에 고유 IP와 단일 DNS 이름을 부여하고, 이를 이용해 로드 밸런싱을 수행합니다.|
|**Automated rollouts & rollbacks**|애플리케이션 또는 설정 변경 시, 전체 인스턴스를 중단하지 않고 점진적으로 컨테이너에 적용(Rolling Update)합니다. 배포 중 문제가 발생하면 자동으로 이전 버전으로 롤백합니다.|
|**Secret & configuration management**|이미지 재빌드 없이 Secrets(비밀값)와 설정 정보를 변경하고 관리할 수 있습니다. 이를 통해 GitHub 같은 저장소에 민감한 정보를 노출시키지 않고 애플리케이션 내에서 공유할 수 있습니다.|
|**Storage Orchestration**|Local storage는 물론 Azure, GCP, AWS와 같은 퍼블릭 클라우드 스토리지나 네트워크 스토리지를 필요에 맞게 자동으로 마운트(mount)할 수 있습니다.|

### 2.3. 클러스터 기본 구조

쿠버네티스 클러스터는 전체 클러스터를 관리하는 **마스터(Master)** 노드와 실제 애플리케이션 컨테이너가 실행되는 **워커(Workers)** 노드들로 구성됩니다.

## 3. 쿠버네티스 기본 객체 모델

### 3.1. 선언적(Declarative) 접근 방식

쿠버네티스는 명령형(Imperative) 방식이 아닌 선언적(Declarative) 방식으로 동작합니다.

- **명령형(Imperative)**: "nginx 컨테이너를 3개 실행하고 80포트를 열어줘." 와 같이 순차적인 명령을 내리는 방식.
- **선언적(Declarative)**: "80포트를 오픈한 채로 nginx 컨테이너 3개를 유지해줘." 와 같이 원하는 최종 상태를 정의하는 방식.

쿠버네티스는 사용자가 정의한 **'의도된 상태(Desired State)'**와 실제 상태를 지속적으로 비교하여 차이가 발생하면 이를 일치시키기 위해 자동으로 작동합니다.

### 3.2. 핵심 구성 요소

- **Pod**: 쿠버네티스에서 생성하고 관리할 수 있는 가장 작은 배포 단위입니다.
    - 이름은 고래 떼를 의미하며, 이는 도커(Docker)의 심볼인 고래에서 유래했습니다.
    - 하나의 Pod는 여러 컨테이너를 가질 수 있지만, 스케일링이 컨테이너가 아닌 Pod 단위로 수행되므로 대부분 1~2개의 컨테이너를 가집니다.
    - 하나의 Pod는 하나의 물리 서버(Node) 위에서만 실행됩니다.
- **ReplicaSet**: 지정된 수의 동일한 Pod 복제본이 항상 실행되도록 보장하는 객체입니다. 마이크로서비스(컨테이너)의 개수를 조절하는 데 사용됩니다. 동일 작업을 수행하는 Pod들은 ReplicaSet에 의해 복제 생성됩니다.
- **Service**: 여러 Pod에 대한 안정적인 단일 접근점(네트워크 엔드포인트)을 제공하는 객체입니다. Pod의 IP가 변경되더라도 Service를 통해 외부에서 일관된 주소로 접근할 수 있으며, 로드 밸런싱 기능을 제공합니다.
- **Deployment**: Pod와 ReplicaSet에 대한 선언적 업데이트를 제공합니다. Deployment를 통해 애플리케이션의 롤링 업데이트, 롤백, 스케일링 등을 관리할 수 있습니다.

### 3.3. 배포 모형

쿠버네티스에서의 일반적인 애플리케이션 배포는 다음과 같은 계층 구조를 가집니다.

1. **Service**: 외부 요청을 받아 적절한 Pod로 전달하는 로드 밸런서 역할을 합니다. (예: `http://order:8080`)
2. **Deployment**: ReplicaSet의 생성을 관리하며 애플리케이션의 상태를 정의합니다.
3. **ReplicaSet**: Deployment의 정의에 따라 지정된 수의 Pod가 항상 실행되도록 관리합니다.
4. **Pod**: 실제 애플리케이션 컨테이너가 실행되는 최소 단위입니다.

## 4. 쿠버네티스 운영 및 관리

### 4.1. YAML: 오케스트레이션 기술 언어

쿠버네티스에서는 Pod, Service, Deployment와 같은 객체(Object) 리소스를 생성하기 위해 **YAML** 파일을 사용합니다. 사용자는 YAML 파일에 원하는 객체의 상태(`spec`)를 기술하여 의도된 상태를 정의하고, 이를 `kubectl` 도구를 통해 쿠버네티스 서버에 전달합니다.

YAML 파일의 주요 필드는 다음과 같습니다.

- `apiVersion`: 해당 객체를 생성하는 데 사용할 쿠버네티스 API 버전을 명시합니다.
- `kind`: 생성하려는 객체의 종류를 명시합니다. (예: `Deployment`, `Service`, `Pod`)
- `metadata`: 객체를 식별하기 위한 데이터(이름, 레이블 등)를 포함합니다.
- `spec`: 객체에 대한 '의도된 상태'를 상세하게 기술합니다. (예: 레플리카 수, 컨테이너 이미지, 포트 정보 등)

### 4.2. Kubectl: 커맨드 라인 도구

**Kubectl**은 쿠버네티스 클러스터를 원격에서 관리하기 위한 커맨드 라인 도구(CLI)입니다. 주요 기능은 다음과 같습니다.

- 쿠버네티스 컨텍스트(Context) 설정을 통한 마이크로서비스 배포
- 클러스터 리소스 모니터링 및 통합 관제
- 명령형(Imperative) 또는 선언적(Declarative) 방식의 컨테이너 오케스트레이션 수행

**주요 명령어 예시:**

- **클러스터 연결**: AWS EKS 클러스터에 연결하기 위해 Kubeconfig 파일을 업데이트합니다.
- **연결 확인**: 현재 연결된 클러스터 정보를 확인합니다.
- **리소스 조회**: 클러스터 내의 모든 리소스를 조회합니다.