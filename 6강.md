# 운영체제 쓰레드

## 핵심 요약

본 문서는 운영체제의 핵심 구성 요소인 쓰레드(Thread)의 개념, 모델 및 관련 주요 이슈를 종합적으로 분석한다. 쓰레드는 CPU 사용의 기본 단위로, 단일 프로세스 내에서 여러 실행 흐름을 가능하게 하여 시스템의 응답성과 효율성을 극대화하는 경량 프로세스(Lightweight Process)이다.

프로세스 생성에 비해 경제적이고 자원 공유가 용이한 다중 쓰레드는 응용 프로그램의 응답성을 향상시키고 다중 처리기 시스템의 성능을 최대한 활용하는 데 필수적이다. 쓰레드는 구현 위치에 따라 사용자 수준과 커널 수준으로 나뉘며, 이 둘을 매핑하는 방식에 따라 **다대일(Many-to-One)**, **일대일(One-to-One)**, **다대다(Many-to-Many)** 모델로 구분된다. 각 모델은 성능, 동시성, 구현 복잡도 측면에서 명확한 장단점을 가진다.

또한, `fork()` 및 `exec()` 시스템 호출의 동작 방식, 쓰레드를 안전하게 종료하는 취소 메커니즘, 그리고 자원 관리 효율을 높이기 위한 쓰레드 풀(Thread Pool) 기법은 다중 쓰레드 환경에서 반드시 고려해야 할 중요한 문제들이다. 본 문서는 이러한 핵심 원리와 문제들을 체계적으로 정리하여 쓰레드에 대한 깊이 있는 이해를 제공한다.

--------------------------------------------------------------------------------

## 1. 쓰레드의 개념과 중요성

### 1.1. 쓰레드의 정의

쓰레드는 하나의 실행 흐름으로서 **CPU 사용의 기본 작업 단위**이다. 전통적인 프로세스(중량 프로세스, Heavyweight Process)가 하나의 제어 흐름을 갖는 반면, 쓰레드는 프로세스 내의 독립적인 실행 단위로 작동하여 **경량 프로세스(LWP, Lightweight Process)**라고도 불린다. 하나의 프로세스가 여러 개의 쓰레드로 구성될 경우, 동시에 하나 이상의 작업을 병렬적으로 수행하는 것이 가능해진다.

각 쓰레드는 다음과 같은 독립적인 실행 문맥을 가진다.

- 쓰레드 ID
- 프로그램 카운터(PC)
- 레지스터 집합
- 스택(Stack)

### 1.2. 프로세스와 쓰레드의 비교

쓰레드는 자신이 속한 프로세스의 자원을 공유한다는 점에서 프로세스와 근본적인 차이를 보인다. 이는 문맥 교환(Context Switching)의 오버헤드와 자원 효율성 측면에서 중요한 장점을 제공한다.

|   |   |   |
|---|---|---|
|구분|프로세스 (Process)|쓰레드 (Thread)|
|**자원 공유**|각 프로세스는 독립적인 메모리 공간과 자원을 할당받음. 통신을 위해 IPC(Inter-Process Communication)와 같은 별도 기법 필요.|동일 프로세스 내 쓰레드들은 텍스트(코드), 데이터, 힙(Heap) 메모리 공간 및 OS 자원(파일 등)을 공유함. 스택은 독립적으로 가짐.|
|**생성 및 관리**|새로운 프로세스를 생성하고 전환하는 데 많은 시스템 자원과 시간이 소요되는 오버헤드가 발생함 (중량 프로세스).|프로세스 내에서 생성되므로 자원 할당 비용이 훨씬 적고 생성 속도가 빠름. 유닉스 시스템의 경우 쓰레드 생성이 프로세스 생성보다 10배 정도 빠르다고 알려짐.|
|**문맥 교환**|메모리 주소 공간을 포함한 전체 문맥을 전환해야 하므로 시간 소모가 큼.|공유하는 메모리 공간이 많아 스택 포인터, 레지스터 등 최소한의 정보만 전환하면 되므로 문맥 교환이 간단하고 빠름.|
|**통신**|공유 메모리, 메시지 전달 등 커널의 중재가 필요한 복잡한 통신 메커니즘을 사용함.|스택을 제외한 메모리 공간을 공유하므로 별도의 통신 기법 없이도 데이터 교환이 용이하고 편리함.|

### 1.3. 다중 쓰레드의 장점

다중 쓰레드 프로그래밍은 다음과 같은 네 가지 주요 이점을 제공한다.

- **응답성 (Responsiveness)**
    - 대화형 응용 프로그램에서 일부 작업이 길어지거나 입출력으로 인해 봉쇄(Block)되더라도, 다른 쓰레드는 계속 실행되어 사용자에 대한 응답성을 유지할 수 있다. 예를 들어, 워드프로세서에서 철자 검사를 하는 쓰레드가 실행되는 동안에도 사용자는 키보드 입력을 계속할 수 있다.
- **자원 공유 (Resource Sharing)**
    - 쓰레드는 별도의 명시적 장치 없이도 자신이 속한 프로세스의 메모리와 자원을 자동으로 공유한다. 이를 통해 효율적인 데이터 공유 및 협업이 가능하다.
- **경제성 (Economy)**
    - 프로세스 생성 및 문맥 교환에 비해 쓰레드를 생성하고 전환하는 비용이 훨씬 저렴하다. 이는 시스템 전체의 오버헤드를 줄여 성능을 향상시킨다.
- **다중처리기 구조 활용 (Utilization of Multiprocessor Architecture)**
    - 단일 쓰레드 프로세스는 CPU가 여러 개 있더라도 하나의 CPU에서만 실행된다. 반면, 다중 쓰레드 프로세스는 여러 개의 쓰레드를 각기 다른 CPU에 할당하여 병렬로 실행할 수 있어 다중처리기(Multi-processor) 시스템의 성능을 극대화할 수 있다.

## 2. 쓰레드 구현 모델

쓰레드는 사용자 공간(User Space) 또는 커널 공간(Kernel Space)에서 구현될 수 있으며, 운영체제는 이 두 수준의 쓰레드를 연결하기 위한 다양한 모델을 제공한다.

### 2.1. 사용자 수준 쓰레드와 커널 수준 쓰레드

- **사용자 수준 쓰레드 (User-Level Threads)**
    - 커널의 지원 없이 사용자 영역의 쓰레드 라이브러리를 통해 구현된다.
    - 쓰레드의 생성, 스케줄링, 관리 등 모든 작업이 커널의 개입 없이 사용자 공간에서 이루어지므로 매우 빠르다.
    - **단점:** 커널은 사용자 쓰레드의 존재를 인식하지 못한다. 따라서 하나의 쓰레드가 입출력과 같은 블록킹 시스템 호출을 하면, 커널은 전체 프로세스를 대기 상태로 전환시켜 해당 프로세스 내의 모든 쓰레드가 함께 멈추게 된다.
- **커널 수준 쓰레드 (Kernel-Level Threads)**
    - 운영체제 커널에 의해 직접 지원되고 관리된다.
    - 쓰레드의 생성과 스케줄링이 모두 커널 공간에서 이루어지며, 커널이 각 쓰레드를 개별적인 실행 단위로 인식한다.
    - 한 쓰레드가 블록되더라도 커널은 동일 프로세스 내의 다른 쓰레드를 계속 실행시킬 수 있다.
    - **단점:** 쓰레드 관리 작업이 커널 모드에서 수행되므로 사용자 수준 쓰레드보다 생성 및 관리 속도가 느리다.

### 2.2. 다중 쓰레드 매핑 모델

사용자 수준 쓰레드와 커널 수준 쓰레드를 연결하는 방식에 따라 세 가지 주요 모델로 나뉜다.

- **다대일 모델 (Many-to-One Model)**
    - **설명:** 여러 개의 사용자 수준 쓰레드를 단 하나의 커널 수준 쓰레드로 매핑한다.
    - **장점:** 모든 쓰레드 관리가 사용자 공간에서 이루어져 매우 효율적이고 빠르다.
    - **단점:**
        - 하나의 쓰레드가 블록킹 시스템 호출을 하면 전체 프로세스가 멈춘다.
        - 여러 개의 쓰레드가 있어도 실제로는 하나의 커널 쓰레드만 존재하므로, 다중처리기 환경에서 병렬 실행이 불가능하다.
- **일대일 모델 (One-to-One Model)**
    - **설명:** 각각의 사용자 수준 쓰레드를 개별적인 커널 수준 쓰레드로 매핑한다.
    - **장점:**
        - 하나의 쓰레드가 블록되어도 다른 쓰레드는 정상적으로 실행될 수 있어 동시성이 높다.
        - 다중처리기 환경에서 여러 쓰레드가 병렬로 실행될 수 있다.
    - **단점:**
        - 사용자 쓰레드를 생성할 때마다 커널 쓰레드를 생성해야 하므로 오버헤드가 크다.
        - 시스템이 생성할 수 있는 커널 쓰레드 수에 제한이 있어, 생성 가능한 쓰레드 수가 제한될 수 있다.
- **다대다 모델 (Many-to-Many Model)**
    - **설명:** 여러 개의 사용자 수준 쓰레드를 그보다 적거나 같은 수의 커널 수준 쓰레드 집합으로 매핑한다.
    - **장점:**
        - 일대일 모델보다 생성 오버헤드가 적고, 다대일 모델의 블로킹 및 병렬성 문제를 해결한 균형 잡힌 모델이다.
        - 개발자는 필요한 만큼 사용자 쓰레드를 생성하고, 커널은 가용한 커널 쓰레드에 이들을 적절히 스케줄링하여 동시성을 보장한다.
    - **단점:** 두 수준의 스케줄러를 관리해야 하므로 구현이 복잡하다.

## 3. 주요 쓰레드 관련 이슈 및 해결 방안

다중 쓰레드 환경에서는 프로세스 관리, 자원 회수, 효율성 측면에서 몇 가지 중요한 문제들이 발생한다.

### 3.1. 와 시스템 호출

- `**fork()**` **시스템 호출:** 다중 쓰레드 프로세스 내의 한 쓰레드가 `fork()`를 호출할 때, 새로 생성되는 자식 프로세스가 부모의 모든 쓰레드를 복제해야 하는지, 아니면 `fork()`를 호출한 쓰레드만 복제해야 하는지에 대한 문제가 발생한다. 이는 운영체제나 API에 따라 다르게 처리될 수 있다.
- `**exec()**` **시스템 호출:** 쓰레드가 `exec()`를 호출하면, 해당 시스템 호출에 지정된 새로운 프로그램이 현재 프로세스의 메모리 공간 전체를 대체한다. 따라서 기존에 실행되던 모든 쓰레드를 포함한 전체 프로그램이 새로운 프로그램으로 교체된다.

### 3.2. 쓰레드 취소 (Thread Cancellation)

쓰레드가 작업을 완료하기 전에 강제적으로 종료시키는 것을 쓰레드 취소라고 하며, 취소 대상이 되는 쓰레드를 '타겟 쓰레드(Target Thread)'라고 한다. 자원을 안전하게 회수하기 위해 두 가지 방식이 사용된다.

- **비동기 취소 (Asynchronous Cancellation):** 한 쓰레드가 타겟 쓰레드를 즉시 종료시킨다. 타겟 쓰레드가 자원을 할당받아 사용 중인 상태에서 갑자기 종료되면 자원 불일치나 누수 문제가 발생할 수 있다.
- **지연 취소 (Deferred Cancellation):** 타겟 쓰레드가 주기적으로 자신이 종료되어야 하는지 여부를 확인한다. 이 방식은 타겟 쓰레드에게 점검 지점(cancellation point)에서 스스로 정리 작업을 수행하고 질서정연하게 종료될 기회를 주므로 더 안전하다.

### 3.3. 쓰레드 풀 (Thread Pools)

서비스 요청이 있을 때마다 새로운 쓰레드를 생성하는 것은 상당한 시간적 오버헤드를 유발하며, 무제한으로 쓰레드를 생성하면 시스템 자원이 고갈될 수 있다. 쓰레드 풀은 이러한 문제를 해결하기 위한 기법이다.

- **작동 방식:**
    1. 프로세스 시작 시, 미리 정해진 개수의 쓰레드를 생성하여 '풀(Pool)'에 보관한다.
    2. 요청이 들어오면 풀에서 대기 중인 쓰레드 하나를 할당하여 작업을 처리하게 한다.
    3. 작업이 완료된 쓰레드는 종료되지 않고 다시 풀로 돌아가 다음 요청을 기다린다.
- **장점:**
    - **성능 향상:** 기존 쓰레드를 재사용하므로 쓰레드 생성에 따른 오버헤드가 없어 요청 처리 속도가 빠르다.
    - **자원 관리:** 동시에 실행되는 쓰레드의 최대 개수를 제한하여 시스템의 안정성을 높인다. 쓰레드 풀의 크기는 CPU 수, 메모리 용량, 예상 동시 요청 수 등을 고려하여 최적화할 수 있다.