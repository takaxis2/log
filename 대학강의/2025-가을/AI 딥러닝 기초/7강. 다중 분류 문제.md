#  : 아이리스 품종 분류 사례 연구

## Executive Summary

본 문서는 3개 이상의 클래스 중 하나를 예측하는 다중 분류(Multi-class Classification) 문제의 핵심 개념과 딥러닝 모델 구현 과정을 종합적으로 다룬다. 아이리스(붓꽃) 품종 분류를 주요 사례로 사용하여, 데이터 탐색부터 모델 구축, 학습 설정에 이르는 전 과정을 체계적으로 분석한다.

핵심적으로, 데이터의 변수 간 관계를 시각적으로 파악하기 위한 **상관도 그래프(`pairplot`)**의 활용법, 딥러닝 모델이 처리할 수 있도록 문자열 데이터를 숫자형 벡터로 변환하는 **원-핫 인코딩(One-Hot Encoding)** 기법을 설명한다. 또한, 다중 분류 모델의 출력층에서 각 클래스에 대한 예측 확률을 계산하는 데 필수적인 **소프트맥스(Softmax) 활성화 함수**와, 모델의 오차를 측정하고 학습 방향을 결정하는 **범주형 교차 엔트로피(Categorical Cross-Entropy) 손실 함수**의 원리와 적용 방안을 상세히 기술한다. 본 문서는 이러한 핵심 요소들을 종합하여 다중 분류 문제 해결을 위한 완전한 딥러닝 파이프라인을 제시한다.

--------------------------------------------------------------------------------

## 1. 다중 분류 문제의 이해

### 정의 및 특징

다중 분류(Multi-class Classification)는 **3개 이상의 선택지(클래스) 중에서 하나의 정답을 예측하는** 분류 문제를 의미한다. 이는 '생존/사망'과 같이 두 가지 중 하나를 선택하는 이항 분류(Binary Classification)와는 접근 방식에서 차이를 보인다. 다중 분류 문제는 각 클래스에 대한 예측 확률을 개별적으로 계산하여 가장 확률이 높은 클래스를 최종 예측값으로 선택하는 방식으로 해결된다.

|   |   |   |
|---|---|---|
|분류 유형|예시|설명|
|**이항 분류**|폐암 환자의 1년 후 생존 여부 예측|'생존' 또는 '사망' 두 가지 결과 중 하나를 예측한다.|
|**다중 분류**|아이리스 품종 분류|'Setosa', 'Versicolor', 'Virginica' 세 가지 품종 중 하나를 예측한다.|

### 사례 연구: 아이리스 품종 분류

본 분석에서는 아이리스(붓꽃)의 품종을 분류하는 문제를 통해 다중 분류의 개념을 탐구한다. 아이리스 데이터셋은 딥러닝을 사용하여 품종을 구별하는 대표적인 예시로 활용된다.

- **속성 (Features)**: 총 4개의 연속형 데이터
    - 꽃받침 길이 (sepal length)
    - 꽃받침 너비 (sepal width)
    - 꽃잎 길이 (petal length)
    - 꽃잎 너비 (petal width)
- **클래스 (Labels)**: 총 3개의 범주형 데이터
    - Iris-setosa
    - Iris-versicolor
    - Iris-virginica

## 2. 데이터 탐색 및 전처리

### 상관도 그래프를 이용한 시각적 분석

상관도 그래프는 데이터셋에 포함된 모든 변수 쌍 간의 관계를 산점도로 시각화하여 데이터의 패턴을 한눈에 파악하게 해주는 강력한 도구이다. 시본(seaborn) 라이브러리의 `pairplot()` 함수를 통해 구현할 수 있다.

- **기능**:
    - **산점도**: 각 변수 쌍의 관계를 시각적으로 보여준다.
    - **히스토그램**: 그래프의 대각선 영역에는 각 속성의 품종별 분포가 히스토그램으로 표시된다.
- **핵심 파라미터**:
    - `hue`: 이 옵션에 범주형 변수(예: 'species')를 지정하면, 각 클래스를 서로 다른 색상으로 구분하여 시각화할 수 있다. 이를 통해 품종별로 꽃잎과 꽃받침의 크기 및 너비가 어떤 뚜렷한 차이를 보이는지 직관적으로 분석할 수 있다.

```python
# 상관도 그래프 생성 예시 코드
import seaborn as sns
import matplotlib.pyplot as plt

# df는 아이리스 데이터가 담긴 데이터프레임
sns.pairplot(df, hue='species');
plt.show()
```

### 원-핫 인코딩 (One-Hot Encoding)

딥러닝 모델은 수치 계산을 기반으로 작동하므로, 'Iris-setosa'와 같은 문자열 데이터를 직접 처리할 수 없다. 따라서 이를 숫자 형식으로 변환하는 전처리 과정이 필수적이며, 이때 원-핫 인코딩이 사용된다.

- **정의**: 여러 값으로 구성된 문자열 데이터를 0과 1로만 이루어진 벡터 형태로 변환하는 기법이다.
- **과정**:
    1. 원본 컬럼에 존재하는 고유한 문자열 값(예: 3개의 품종) 각각을 새로운 컬럼의 이름으로 지정한다.
    2. 각 데이터 샘플에 대해, 자신의 실제 값에 해당하는 컬럼에는 **1 (hot)**을, 나머지 컬럼에는 **0**을 할당한다.
- **구현**: 파이썬의 판다스(Pandas) 라이브러리가 제공하는 `get_dummies()` 함수를 사용하면 이 과정을 간단하게 수행할 수 있다.

## 3. 딥러닝 모델 설계 및 구현

### 인공신경망 구조 설계

케라스(Keras)의 `Sequential()` API를 사용하여 층을 순차적으로 쌓아 인공신경망 모델을 구성한다. 각 층은 `Dense` 레이어로 정의되며, 이를 `model.add()` 메소드를 통해 추가한다.

- **Dense Layer (밀집층)**: 한 층의 모든 뉴런이 다음 층의 모든 뉴런과 완전하게 연결된 층(Fully Connected Layer)이다.
- **입력층**: 케라스에서는 별도의 입력층을 만들지 않고, 첫 번째 은닉층에 `input_dim` 파라미터를 설정하여 입력 데이터의 차원(속성의 개수)을 지정한다. 아이리스 데이터는 4개의 속성을 가지므로 `input_dim=4`로 설정한다.
- **모델 구조 예시 (4x12x8x3)**:
    - **입력층**: 4개의 뉴런 (input_dim=4)
    - **은닉층 1**: 12개의 뉴런, 활성화 함수로 ReLU 사용
    - **은닉층 2**: 8개의 뉴런, 활성화 함수로 ReLU 사용
    - **출력층**: 3개의 뉴런 (분류할 클래스 개수), 활성화 함수로 Softmax 사용

```python
# 모델 구조 정의 예시 코드
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense

model = Sequential()
model.add(Dense(12, input_dim=4, activation='relu')) # 입력층(4) + 은닉층1(12)
model.add(Dense(8, activation='relu'))               # 은닉층2(8)
model.add(Dense(3, activation='softmax'))            # 출력층(3)

# 모델 구조 요약 출력
model.summary()
```

### 핵심 활성화 함수

|   |   |   |
|---|---|---|
|함수명|위치|역할 및 특징|
|**렐루 (ReLU)**|은닉층|**Rectified Linear Unit**. 입력값이 음수이면 0을, 양수이면 입력값을 그대로 출력(`max(0, x)`). 학습 과정에서 기울기가 소멸하는 문제를 해결하는 데 효과적이다.|
|**소프트맥스 (Softmax)**|출력층|다중 분류 문제의 출력층에 사용. K개의 실수 벡터 입력을 받아 각 요소가 **0과 1 사이의 값**을 가지며, **총합이 1**이 되는 확률 분포로 변환한다. 지수 함수를 사용하여 클래스 간 값의 차이를 증폭시켜 가장 가능성 높은 클래스를 부각시킨다.|

### 모델 컴파일 및 학습 설정

모델 구조를 정의한 후, `model.compile()` 메소드를 통해 학습 과정을 설정한다. 이는 모델이 효과적으로 학습될 수 있도록 환경을 구성하는 단계이다.

- `**loss**` **(손실 함수)**: 모델의 예측이 얼마나 틀렸는지를 측정하는 함수. 다중 분류 문제에서는 `**categorical_crossentropy**` (범주형 교차 엔트로피)를 사용한다.
- `**optimizer**` **(옵티마이저)**: 손실 함수의 값을 최소화하기 위해 모델의 가중치를 업데이트하는 방법. 일반적으로 성능이 우수한 **`adam`**이 널리 사용된다.
- `**metrics**` **(평가 지표)**: 학습 및 검증 과정에서 모델의 성능을 모니터링하는 지표. 분류 문제에서는 주로 `**accuracy**` (정확도)를 사용한다.

## 4. 손실 함수와 모델 평가

### 손실 함수의 역할

인공신경망의 학습은 출력층에서 계산된 예측값과 실제 정답 값의 차이인 **오차(Error)를 최소화**하는 최적의 가중치(weight)와 편향(bias)을 찾는 과정이다. 이 오차는 손실 함수(Loss Function)를 통해 정량적으로 계산되며, 손실 값이 0에 가까울수록 모델의 예측이 완벽에 가깝다는 것을 의미한다.

### 분류 문제의 손실 함수

분류 문제에서는 일반적으로 교차 엔트로피(Cross-Entropy) 계열의 손실 함수를 사용한다.

|   |   |   |
|---|---|---|
|손실 함수명|사용 사례|정의|
|**이항 교차 엔트로피**|이항 분류 (2개 클래스 예측)|두 개의 클래스 중 하나를 예측할 때 사용|
|**범주형 교차 엔트로피**|다중 분류 (3개 이상 클래스 예측)|여러 클래스 중 하나를 예측할 때 사용|

_참고: 회귀 모델에서는 평균 제곱 오차(MSE), 평균 절대 오차(MAE) 등의 손실 함수가 사용된다._

### 결과 재현성에 대한 고찰

텐서플로(TensorFlow)와 같은 딥러닝 라이브러리는 신경망의 가중치를 초기화할 때 무작위성을 포함한다. 이로 인해 코드를 여러 번 실행할 때마다 결과가 미세하게 달라질 수 있다. 하지만 모델이 안정적으로 최적점에 수렴한다면, 이러한 차이는 일반적으로 크지 않다.