

## Executive Summary

본 문서는 분산 메시지 스트리밍 플랫폼으로서 아파치 카프카(Apache Kafka)의 핵심 개념, 아키텍처, 그리고 동작 원리를 종합적으로 분석한다. 전통적인 요청-응답(Request-Response) 방식의 애플리케이션 아키텍처는 시스템 간의 강한 결합(Point-to-Point)으로 인해 '스파게티 네트워크'를 형성하고, 장애가 시스템 전체로 전파될 위험이 있다. 이에 대한 대안으로 제시된 이벤트 기반 아키텍처(Event-Driven Architecture, EDA)는 비동기(Non-Blocking) 및 시간적 비동기화(Time-decoupled) 통신을 통해 시스템 장애를 격리하고 유연성을 확보한다.

카프카는 이러한 EDA 기반 마이크로서비스 통신을 위한 최고의 분산 메시징 플랫폼으로, LinkedIn에서 개발되어 대용량 실시간 로그 처리에 특화된 솔루션이다. 카프카의 핵심은 **토픽(Topic)**, **파티션(Partition)**, **오프셋(Offset)** 개념에 있다. 토픽은 메시지를 분류하는 채널 역할을 하며, 파티션은 토픽 내에서 메시지를 분산 저장하여 병렬 처리를 가능하게 한다. 오프셋은 각 컨슈머가 파티션의 메시지를 어디까지 소비했는지를 기록하여, 장애 발생 시에도 중단된 지점부터 작업을 재개할 수 있게 한다.

특히 중요한 것은 **메시지 순서성 보장**이다. 다중 파티션 및 다중 컨슈머 환경에서 데이터 일관성을 유지하기 위해, 동일한 비즈니스 프로세스에서 발생하는 연속된 메시지들은 반드시 동일한 파티션에 저장되어야 한다. 이는 프로듀서가 메시지를 발행할 때 특정 **키(Key)**를 지정함으로써 달성된다. 카프카는 이 키의 해시값을 기반으로 메시지를 특정 파티션에 할당하여, 컨슈머가 관련 이벤트를 순서대로 처리할 수 있도록 보장한다.

--------------------------------------------------------------------------------

## 1. 아키텍처 패러다임의 전환: 요청-응답 모델에서 이벤트 기반 아키텍처(EDA)로

애플리케이션 통신 방식은 시스템의 확장성, 유연성, 안정성에 직접적인 영향을 미친다. 전통적인 모델과 현대적인 이벤트 기반 모델은 다음과 같은 뚜렷한 차이점을 보인다.

|   |   |   |
|---|---|---|
|구분|전통적인 요청-응답 애플리케이션|이벤트 기반 애플리케이션 (EDA)|
|**통신 방식**|Point-to-Point (점대점)|Broadcasting (방송)|
|**동작 모델**|Blocking Model (동기식)|Non-Blocking Model (비동기식)|
|**결합도**|강한 결합 (Tightly Coupled)|시간적 비동기화 (Time-decoupled)|
|**장애 처리**|시스템 장애 전파 (System fault spread)|시스템 장애 격리 (System fault isolation)|
|**구조**|스파게티 네트워크 (Spaghetti network) 형성 가능성|이벤트 발행/구독(Publish/Subscribe) 모델|

EDA 모델에서는 '주문(Orders)' 서비스가 'Order Placed' 이벤트를 발행하면, 해당 이벤트에 관심 있는 '배송(Shipping)' 및 '마케팅(Marketing)' 서비스가 이를 구독하여 독립적으로 후속 작업을 처리한다. 이처럼 서비스 간의 의존성을 제거함으로써 전체 시스템의 유연성과 회복탄력성이 향상된다.

## 2. 아파치 카프카(Apache Kafka) 개요

카프카는 대용량 데이터 스트림을 실시간으로 처리하기 위해 설계된 분산 메시징 플랫폼이다.

- **기원**: LinkedIn에서 개발되어 2011년 오픈소스로 공개되었다.
- **특징**: 대용량의 실시간 로그 처리에 특화된 아키텍처를 가지고 있다.
- **주요 활용 분야**:
    - 메시징 시스템
    - 사용자 활동 추적 (Activity Tracking)
    - 모니터링 데이터 수집
    - 로그 수집 (Log Aggregation)
    - 스트림 처리 (Stream Processing)

## 3. 카프카 핵심 구성 요소

카프카는 여러 핵심 구성 요소들의 유기적인 상호작용을 통해 동작한다.

### 3.1. 토픽 (Topics)

메시지가 저장되고 소비되는 논리적인 통로로, 데이터베이스의 테이블이나 채팅 애플리케이션의 그룹 채팅방과 유사한 개념이다. 카프카 클러스터 내에서 수많은 메시지들은 토픽을 기준으로 구분되어 관리된다.

### 3.2. 파티션 (Partitions)

하나의 토픽을 구성하는 물리적인 저장소로, 메시지가 분산되어 저장된다.

- **순서 보장**: 동일한 파티션 내에서는 메시지가 저장된 순서(Offset 순)가 보장된다.
- **불변성**: 파티션에 한 번 쓰여진 데이터는 변경되지 않는다.
- **분산 저장**: 프로듀서가 메시지를 발행하면 기본적으로 여러 파티션에 라운드 로빈 방식으로 균등하게 분산 저장된다.

### 3.3. 오프셋 (Offsets)

파티션 내에서 컨슈머가 메시지를 어디까지 읽었는지를 나타내는 값이다.

- 각 마이크로서비스(컨슈머 그룹)별로 오프셋이 개별적으로 관리된다. 이는 각 서비스가 자신의 속도에 맞춰 독립적으로 메시지를 처리할 수 있게 하는 EDA 통신의 근간이 된다.
- 모든 컨슈머는 카프카에 접속할 때 자신의 오프셋을 기준으로 다음 메시지를 가져와(Polling) 처리한다.

### 3.4. 브로커 (Broker)

카프카 클러스터를 구성하는 개별 서버를 지칭한다.

- 각 브로커는 하나 이상의 토픽 파티션을 보유한다.
- 클라이언트는 어느 브로커에 접속하든 전체 카프카 클러스터와 통신할 수 있다.
- 일반적으로 3대로 시작하여 수백 대까지 확장할 수 있다.

### 3.5. 복제 (Replication) 및 리더 (Leader)

고가용성과 장애 복구를 위해 토픽의 파티션을 여러 브로커에 복제하는 기능이다.

- **Replication Factor**: 파티션을 몇 개로 복제할지 지정하는 값. 예를 들어, Replication Factor가 2이면 원본 파티션 1개와 복제본 1개가 생성된다.
- **파티션 리더 (Leader)**: 복제된 파티션들 중 실제 데이터의 읽기(Read)와 쓰기(Write)를 담당하는 유일한 파티션이다.
- **ISR (In-Sync Replica)**: 리더를 제외한 나머지 복제본들. 이들은 리더의 데이터를 실시간으로 복제하며, 리더에 장애가 발생할 경우 새로운 리더 역할을 수행한다.

### 3.6. 프로듀서 (Producer)

메시지를 생산하여 특정 토픽으로 전송하는 애플리케이션이다.

- **Key 옵션**: 메시지를 전송할 때 키(Key)를 지정할 수 있다. 키가 지정된 메시지는 키의 해시값에 따라 특정 파티션으로 전송된다.
- **라운드 로빈**: 키를 지정하지 않으면 메시지는 토픽 내의 파티션들에 균등하게 분배된다.

### 3.7. 컨슈머 (Consumer) 및 컨슈머 그룹 (Consumer Group)

토픽으로부터 메시지를 가져가 소비하는 애플리케이션이다.

- **컨슈머 그룹**: 하나 이상의 컨슈머들로 구성된 집합. 카프카는 컨슈머 그룹 단위로 데이터를 처리한다.
- **파티션 할당**: 하나의 컨슈머 그룹 내에서 각 컨슈머는 하나 이상의 파티션에 할당되어 데이터를 소비한다. 이를 통해 메시지 처리를 병렬화할 수 있다.

## 4. 카프카의 주요 동작 원리

### 4.1. 지연 (Lag)

프로듀서가 발행한 메시지의 최신 오프셋과 컨슈머가 마지막으로 소비한 메시지의 오프셋 간의 차이를 '랙(Lag)'이라고 한다. 랙은 컨슈머의 처리 속도가 프로듀서의 발행 속도를 따라가지 못하고 있음을 나타내는 지표로 활용된다.

### 4.2. 리밸런싱 (Rebalancing)

컨슈머 그룹의 파티션 소유권을 재할당하는 과정이다. 리밸런싱은 다음과 같은 경우에 발생한다.

- 토픽의 파티션 수가 동적으로 변경될 때
- 컨슈머 그룹에 새로운 컨슈머가 추가되거나 기존 컨슈머가 제거될 때 (장애 포함)

리밸런싱이 발생하면 카프카 클러스터는 그룹 내의 컨슈머들에게 파티션을 공정하게 재분배한다. 이 과정 중에도 프로듀서는 계속해서 모든 파티션에 메시지를 균등하게 분배하여 저장한다.

### 4.3. 메시지 순서성 보장

멀티 파티션, 멀티 컨슈머 환경에서 데이터의 정합성을 유지하기 위해 가장 중요한 것은 **메시지 처리 순서를 보장**하는 것이다.

- **문제점**: 특정 주문(예: PO#1)에 대한 `OrderPlaced`, `OrderModified`, `OrderDeleted` 이벤트가 순서대로 발생했다고 가정하자. 만약 이 메시지들이 키 없이 발행되어 서로 다른 파티션에 저장되면, 컨슈머는 `OrderPlaced`보다 `OrderModified` 메시지를 먼저 처리할 수 있다. 이 경우, 아직 생성되지 않은 주문을 수정하려 시도하게 되어 시스템 오류가 발생한다.
- **해결책**: **메시지 키(Key)를 사용**하는 것이다. 프로듀서가 `주문 ID`와 같은 동일한 키를 사용하여 관련 메시지들을 발행하면, 카프카는 해당 키의 해시값을 계산하여 항상 동일한 파티션에 메시지를 적재한다.
- **동작 방식**:
    1. 프로듀서는 메시지(예: `msg`)와 함께 키(예: `key1`)를 발행한다: `Pub(key1, msg)`
    2. 카프카는 키의 해시값을 계산하여 일관되게 특정 파티션을 매칭하고 메시지를 적재한다.
    3. 컨슈머는 특정 파티션의 메시지를 순서대로 소비하므로, 동일한 키를 가진 이벤트들을 발생 순서대로 처리할 수 있다.

## 5. 결론 및 핵심 요약

카프카는 이벤트 기반 마이크로서비스 아키텍처에서 시스템 간의 결합도를 낮추고 데이터 스트림을 효과적으로 처리하기 위한 강력한 솔루션이다. 카프카를 성공적으로 활용하기 위한 가장 핵심적인 원칙은 **데이터의 순서성 보장**이다.

"비즈니스 적으로 동일 프로세스에서 발생하는 메시지들은 이를 처리하는 컨슈머 입장에서 순서성이 보장되려면, 메시지가 반드시 동일한 파티션에 적재되도록 해 주어야 함"

결론적으로, 순서가 중요한 비즈니스 로직을 처리할 때는 반드시 관련 메시지들을 식별할 수 있는 고유한 키를 사용하여 발행해야 한다. 이는 카프카가 제공하는 병렬 처리의 이점을 누리면서도 데이터의 정합성과 일관성을 유지하는 핵심적인 전략이다.