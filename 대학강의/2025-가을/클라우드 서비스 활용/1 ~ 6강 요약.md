# 마이크로서비스 아키텍처(MSA)와 이벤트 기반 설계 핵심 브리핑

### Executive Summary

본 문서는 기존의 모노리스(Monolith) 아키텍처에서 마이크로서비스 아키텍처(MSA)로의 전환이 현대 비즈니스의 민첩성과 확장성 요구에 부응하기 위한 필수적인 패러다임 변화임을 설명한다. MSA는 거대한 단일 시스템을 작고, 독립적으로 배포 가능한 서비스들의 집합으로 분해하여 개발 생산성을 높이고 장애의 영향을 최소화한다.

이러한 분산 환경에서 서비스 간 통신 방식은 시스템 전체의 안정성을 좌우하는 핵심 요소이다. 전통적인 동기식 REST 호출 방식은 '타임 커플링(Time Coupling)' 문제를 야기하여 시스템 전반에 걸친 장애 전파의 위험을 내포한다. 이에 대한 해결책으로, 비동기 메시징 기반의 **이벤트 기반 아키텍처(Event-Driven Architecture, EDA)**가 각광받고 있다. EDA는 Pub/Sub 모델을 통해 서비스 간의 결합도를 낮추고, 장애 격리(Fault Isolation)를 보장하여 시스템의 회복탄력성을 극대화한다.

성공적인 MSA 전환을 위해서는 체계적인 분석 및 설계 방법론이 필수적이다. **도메인 주도 설계(Domain-Driven Design, DDD)**는 비즈니스 도메인의 복잡성을 소프트웨어 모델에 그대로 반영하는 접근법이며, **이벤트스토밍(EventStorming)**은 DDD를 가장 효과적으로 실천할 수 있는 협업 기반의 시각적 워크샵 기법이다. 이벤트스토밍을 통해 도출된 설계 모델은 헥사고날 아키텍처(Hexagonal Architecture)를 통해 스프링 부트(Spring Boot)와 같은 프레임워크로 구현되며, 최종적으로는 도커(Docker) 컨테이너로 패키징되어 쿠버네티스(Kubernetes) 환경에서 자동화된 방식으로 배포 및 운영된다.

--------------------------------------------------------------------------------

### 1. 패러다임의 전환: 모노리스에서 마이크로서비스로

소프트웨어 아키텍처는 비즈니스 요구사항의 변화에 따라 발전해왔다. 과거의 안정성을 중시하던 계획 중심적 접근에서 현재의 민첩성과 고객 중심적 사고를 강조하는 애자일(Agile) 방식으로 전환되면서, 이를 뒷받침할 수 있는 마이크로서비스 아키텍처가 핵심 기술로 부상했다.

#### 모노리스 아키텍처의 한계

모노리스 아키텍처는 주문, 상품, 배송 등 시스템의 모든 기능 모듈이 하나의 거대한 애플리케이션 내에 통합된 구조를 말한다. 초기에는 상호 데이터 참조가 용이하여 빠른 개발에 적합하지만, 시간이 지남에 따라 다음과 같은 심각한 문제점을 드러낸다.

- **강한 결합도(High Coupling):** 모듈 간 상호 의존성이 높아 하나의 작은 변경이 연관된 다른 많은 컴포넌트의 수정을 유발한다.
- **개발 생산성 저하:** 코드량이 방대해져 오류 발생 시 원인 파악이 어렵고, 개발 환경이 무거워져 기동 시간이 길어진다.
- **배포의 어려움:** 작은 수정 사항 하나를 반영하기 위해 전체 시스템을 다시 테스트하고 재배포해야 하므로, 지속적 딜리버리가 어렵고 배포 시간이 과도하게 소요된다.
- **제한적인 확장성:** 특정 기능에 대한 트래픽이 급증해도 해당 모듈만 선별적으로 확장하기가 용이하지 않다.
- **기술 스택의 경직성:** 전체 시스템이 하나의 기술 스택(예: Java 1.8 + Oracle)에 종속되어 새로운 기술 도입이 어렵다.

#### 마이크로서비스 아키텍처(MSA)의 개념과 장점

마이크로서비스 아키텍처(MSA)는 하나의 큰 애플리케이션을 단일 책임 원칙(Single Responsibility)에 따라 작고, 독립적으로 배포 가능한 서비스의 조합으로 구축하는 아키텍처 스타일이다. 각 서비스는 자체 데이터베이스를 가질 수 있으며, 서로 다른 기술 스택으로 구현될 수 있다.

|   |   |
|---|---|
|장점|설명|
|**이해 용이성**|서비스별 코드량이 작아 이해하기 쉽고, 오류가 숨을 공간이 적어 버그를 찾기 용이하다.|
|**독립적인 배포**|수정된 서비스에 대한 국지적 단위 배포와 테스팅이 가능하여 개발/테스트/배포 일정이 대폭 축소된다.|
|**장애 격리**|한 서비스에서 발생한 장애가 다른 서비스로 전파될 가능성이 낮아 시스템 전체의 안정성이 향상된다.|
|**기술 다양성**|각 서비스의 특성에 맞는 최적의 프로그래밍 언어나 프레임워크를 자유롭게 선택하여 사용할 수 있다.|
|**개발 생산성 향상**|작고 분화된 조직(예: 2-Pizza Team)이 서비스 개발에 집중하여 생산성이 향상된다.|

#### MSA의 도전 과제

MSA는 많은 이점을 제공하지만, 동시에 새로운 복잡성을 야기한다. 이러한 도전 과제를 해결하기 위해 MSA 디자인 패턴과 DevOps 환경 구축이 필수적이다.

- **서비스 분리 기준:** "서비스를 어떻게 나눌 것인가?"는 MSA 도입 시 가장 어려운 문제 중 하나이다.
- **운영 복잡성:** 관리해야 할 서비스의 수가 많아져 배포, 모니터링, 운영이 복잡해지므로 쿠버네티스와 같은 DevOps 환경이 반드시 필요하다.
- **통합 테스트의 어려움:** 여러 서비스에 걸친 전체적인 비즈니스 흐름을 테스트하기가 복잡하다.
- **분산 데이터 관리:** 분산된 서비스 간의 데이터 일관성을 어떻게 보장할 것인가(분산 트랜잭션)는 중요한 과제이다.

--------------------------------------------------------------------------------

### 2. 마이크로서비스 통신 전략: 동기식 REST와 이벤트 기반 아키텍처

분리된 마이크로서비스들은 서로 통신하며 전체적인 비즈니스 로직을 완성한다. 이때 사용되는 통신 방식은 시스템의 결합도와 회복탄력성에 직접적인 영향을 미친다.

#### 동기식 REST 통신과 그 한계

REST API를 통한 동기식(Synchronous) 호출은 마이크로서비스 간 통신에서 널리 사용되는 방식이다. 클라이언트가 서버에 요청(Request)을 보내고 응답(Response)을 받을 때까지 대기하는 모델이다.

- **한계점: 타임 커플링(Time Coupling):** 호출하는 서비스는 호출받는 서비스의 처리가 끝날 때까지 기다려야 한다. 이로 인해 호출된 서비스의 지연이나 장애가 호출한 서비스로 전파되어 시스템 전체의 블로킹 장애를 유발할 수 있다. 이는 "Point to Point 연결에 따른 복잡한 스파게티 네트워크" 문제를 심화시킨다.
- **대응책: 서킷 브레이커(Circuit Breaker):** 장애가 발생한 서비스에 대한 반복적인 호출을 차단하고, 일시적으로 대체 응답(Fallback)을 제공하여 장애 전파를 막는 패턴이다. 장애 감지 시 차단기를 열고(Open), 일정 시간 후 일부 트래픽으로 정상 여부를 확인하여 정상화되면 차단기를 닫는다(Close).

#### 이벤트 기반 아키텍처(EDA)의 부상

이벤트 기반 아키텍처(EDA)는 서비스 간의 통신을 위해 메시지 큐(예: Apache Kafka)를 중간에 두고, 비동기적인 방식으로 메시지를 주고받는 구조이다. 이는 게시-구독(Publish-Subscribe) 모델을 기반으로 한다.

- **개념:** 특정 서비스(Producer)에서 "주문이 발생함(Order Placed)"과 같은 의미 있는 사건, 즉 **도메인 이벤트(Domain Event)**가 발생하면 이를 메시지 큐에 발행(Publish)한다. 이 이벤트에 관심 있는 다른 서비스들(Consumers)은 해당 이벤트를 구독(Subscribe)하여 필요한 후속 처리를 수행한다.
- **핵심 이점:**
    - **런타임 약결합(Loosely Coupled):** 이벤트를 발행하는 서비스는 누가 이벤트를 수신하는지 알 필요가 없으며, 수신을 기다리지 않는다(Non-blocking). 이는 서비스 간의 의존성을 제거하고 타이밍을 분리(Decouples "timing")한다.
    - **장애 격리(Fault Isolation):** 특정 서비스의 장애가 메시지 큐를 통해 다른 서비스로 직접 전파되지 않아 시스템 전체의 안정성과 회복탄력성이 크게 향상된다.
    - **확장성:** 새로운 기능 요구사항이 발생했을 때, 기존 서비스의 수정 없이 새로운 구독자(서비스)를 추가하는 것만으로 쉽게 시스템을 확장할 수 있다(Open in extensibility).

--------------------------------------------------------------------------------

### 3. MSA 설계를 위한 핵심 방법론: 도메인 주도 설계(DDD)와 이벤트스토밍

MSA의 가장 큰 난제인 '서비스를 어떻게 나눌 것인가'에 대한 해답은 비즈니스 도메인 자체에 있다.

#### 도메인 주도 설계(DDD)의 원칙

DDD는 데이터 중심의 접근법에서 벗어나, 비즈니스 도메인 모델과 로직에 집중하는 설계 방식이다. 도메인 전문가와 개발자가 원활하게 소통하며 소프트웨어 설계를 비즈니스 도메인에 그대로 반영하는 것을 목표로 한다.

- **핵심 개념:**
    - **유비쿼터스 언어(Ubiquitous Language):** 도메인 전문가와 개발팀이 모두 사용하는 보편적인 공통 언어.
    - **바운디드 컨텍스트(Bounded Context):** 동일한 문맥 내에서 용어(도메인 클래스)가 특정 의미를 갖는 경계. 각 바운디드 컨텍스트는 마이크로서비스의 후보가 된다.
    - **서브도메인 분류:**
        - **핵심 도메인(Core Domain):** 기업의 핵심 경쟁력과 직결되는 영역 (예: 쇼핑몰의 주문, 상품).
        - **지원 도메인(Supporting Domain):** 핵심 비즈니스를 지원하지만 경쟁력은 아닌 영역 (예: 배송, 추천).
        - **일반 도메인(General Domain):** 비즈니스에 특화되지 않은 일반적인 기능 (예: 결제, 빌링).

#### 이벤트스토밍: 협업 기반의 시각적 분석/설계 기법

이벤트스토밍은 DDD를 실천하는 가장 효율적이고 손쉬운 방법론이다. 도메인 전문가를 포함한 모든 이해관계자가 참여하여, 시스템에서 발생하는 **'이벤트'**를 중심으로 비즈니스 프로세스를 시각화하고 도메인 모델을 설계하는 워크샵 기반의 기법이다.

#### 이벤트스토밍 프로세스 및 구성 요소

이벤트스토밍은 색깔이 다른 스티커(포스트잇)를 사용하여 넓은 벽에 비즈니스 흐름을 모델링한다.

|   |   |   |
|---|---|---|
|스티커 종류|색상|설명|
|**도메인 이벤트**|주황색(Orange)|발생한 사실, 결과. 동사의 과거형으로 표현 (예: `OrderPlaced`)|
|**커맨드**|하늘색(Sky Blue)|이벤트를 유발하는 사용자의 의사결정 또는 시스템의 행위 (예: `Place an order`)|
|**어그리게잇**|노란색(Yellow)|하나의 트랜잭션 단위로 묶이는 엔티티들의 집합. 비즈니스 로직 처리의 주체.|
|**정책**|연보라색(Lilac)|특정 이벤트가 발생했을 때 실행되는 반응형 로직 (예: `When OrderPlaced, Prepare delivery`)|
|**액터(Actor)**|작은 스티커|커맨드를 실행하는 사용자 또는 외부 시스템|
|**읽기 모델**|초록색(Green)|사용자가 의사결정을 위해 참고하는 데이터나 화면(View)|
|**질문/이슈**|보라색(Purple)|논의가 필요한 사항이나 예측되는 리스크|

이벤트스토밍은 두 단계로 진행된다.

1. **프로세스 레벨 이벤트스토밍 (전략적 설계):** 전체 비즈니스 프로세스를 조망하며 도메인 이벤트를 중심으로 바운디드 컨텍스트를 도출하고, 이들 간의 상호작용 방식인 **컨텍스트 매핑(Context Mapping)**을 정의한다. 컨텍스트 매핑은 중앙 컨트롤러가 흐름을 제어하는 **오케스트레이션(Orchestration)** 방식과 각 서비스가 자율적으로 이벤트를 구독하여 처리하는 **코레오그래피(Choreography)** 방식으로 나뉜다.
2. **디자인 레벨 이벤트스토밍 (전술적 설계):** 도출된 각 바운디드 컨텍스트 내부를 상세화하여 개발을 위한 설계도(Blueprint)를 만드는 단계이다. 어그리게잇과 도메인 이벤트의 구체적인 속성을 정의하고, 서비스 간 통신을 위한 메시징 규약을 확정한다.

--------------------------------------------------------------------------------

### 4. 구현 및 운영 전략

이벤트스토밍을 통해 완성된 설계 모델은 실제 코드로 구현되고, 안정적인 플랫폼 위에서 운영되어야 한다.

#### 헥사고날 아키텍처를 통한 설계-코드 매핑

헥사고날 아키텍처(또는 포트 앤 어댑터 아키텍처)는 시스템의 순수한 비즈니스 로직(내부 영역)을 외부의 기술적인 구현(외부 영역, 예: UI, DB, 메시징 시스템)으로부터 분리하는 설계 패턴이다. 이를 통해 이벤트스토밍의 결과를 자연스럽게 코드에 매핑할 수 있다.

- **매핑 예시 (Spring 프레임워크 기반):**
    - **바운디드 컨텍스트** → Spring Boot 애플리케이션 전체
    - **어그리게잇(Aggregate)** → JPA Entity 클래스로 구현된 도메인 모델
    - **커맨드(Command)** → Spring Data REST의 Repository 인터페이스 또는 RestController
    - **이벤트(Event)** → Java POJO(Plain Old Java Object) 클래스
    - **정책(Policy)** → Spring Cloud Stream의 이벤트 리스너(Listener) 코드

이벤트 발행은 주로 JPA의 생명주기 훅(Lifecycle Hook)인 `@PostPersist`(저장 후), `@PostUpdate`(수정 후) 등을 사용하여 어그리게잇의 상태 변화 시점에 자동으로 트리거되도록 구현한다.

#### 컨테이너화 및 오케스트레이션

구현된 마이크로서비스는 안정적이고 확장 가능한 환경에서 운영되어야 한다.

- **컨테이너 (Docker):** 각 마이크로서비스는 실행에 필요한 모든 종속 항목(라이브러리, 런타임 등)과 함께 **도커(Docker)**와 같은 컨테이너 기술을 사용하여 경량 패키지로 만들어진다. 이를 통해 개발 환경과 운영 환경의 차이로 인한 문제를 없애고 일관된 배포를 보장한다.
- **컨테이너 오케스트레이션 (Kubernetes):** 수많은 컨테이너화된 애플리케이션의 배포, 확장, 관리를 자동화하는 시스템이다. **쿠버네티스(Kubernetes)**는 사실상의 표준으로 자리 잡았으며, 다음과 같은 핵심 기능을 제공하여 마이크로서비스의 높은 서비스 수준 협약(SLA)을 보장한다.
    - **자동 배치 및 복제:** 컨테이너를 클러스터 노드에 자동으로 배치하고 원하는 수만큼 복제본을 유지한다.
    - **셀프 힐링(Self-healing):** 장애가 발생한 컨테이너를 자동으로 재시작하거나 교체하여 장애를 복구한다.
    - **로드 밸런싱 및 서비스 노출:** 컨테이너 그룹에 대한 트래픽을 분산하고 외부에서 서비스에 접근할 수 있도록 한다.
    - **자동 확장(Auto Scaling):** 트래픽 부하에 따라 컨테이너 수를 자동으로 늘리거나 줄인다.
    - **무중단 배포(Zero-Downtime Deployment):** 서비스 중단 없이 애플리케이션을 새로운 버전으로 업데이트한다.