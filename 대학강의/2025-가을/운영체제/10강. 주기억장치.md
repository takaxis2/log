
## 개요 (Executive Summary)

본 문서는 운영체제의 핵심 기능 중 하나인 주기억장치 관리에 대한 심층 분석을 제공합니다. 주기억장치(메모리)는 CPU가 직접 접근하여 명령어와 데이터를 처리하는 필수적인 공간으로, 효율적인 관리는 시스템의 전반적인 성능, 특히 다중 프로그래밍 환경의 성능을 좌우합니다.

운영체제는 여러 프로세스에 메모리 공간을 할당하고 회수하는 역할을 수행하며, 이 과정에서 주소 바인딩, 동적 적재, 스와핑 등 다양한 기법을 활용합니다. 주기억장치 할당 방식은 크게 **연속 할당**과 **비연속 할당**으로 나뉩니다.

- **연속 할당**은 프로세스를 메모리의 연속된 공간에 배치하는 단순한 방식이지만, 메모리가 여러 조각으로 나뉘어 낭비되는 **단편화(Fragmentation)** 문제를 야기합니다. 고정 분할 방식은 **내부 단편화**를, 가변 분할 방식은 **외부 단편화**를 발생시킬 수 있습니다.
- **비연속 할당**은 이러한 단편화 문제를 해결하기 위해 프로그램을 여러 조각으로 나누어 메모리 곳곳에 분산시키는 기법입니다. 대표적으로 고정된 크기로 나누는 **페이징(Paging)**과 논리적 의미 단위로 나누는 **세그멘테이션(Segmentation)**이 있으며, 이는 현대 운영체제 메모리 관리의 근간을 이룹니다.

결론적으로, 주기억장치 관리는 제한된 메모리 자원을 최대한 효율적으로 활용하여 다중 프로그래밍의 정도를 높이고 사용자 응답 시간을 단축하는 것을 목표로 하며, 이를 위해 복잡하지만 정교한 할당 및 관리 전략이 요구됩니다.

--------------------------------------------------------------------------------

## 1. 주기억장치 관리의 기초

### 1.1. 주기억장치의 역할과 필요성

주기억장치는 CPU가 프로그램의 명령어와 데이터를 직접 인출하거나 반환할 수 있는 핵심 기억 장치입니다. 모든 정보는 실행되기 위해 반드시 주기억장치에 적재되어야 하므로, 주기억장치는 CPU와 주변 장치 사이의 중요한 매개체 역할을 합니다.

운영체제는 이러한 주기억장치 공간을 여러 프로세스에 효율적으로 할당하고 회수하는 **주기억장치 관리** 기능을 수행합니다. 이는 다중 프로그래밍 환경의 기반이 되며, 다음과 같은 목표를 가집니다.

- **다중 프로그래밍 지원**: 여러 프로그램 코드를 동시에 메모리에 적재하여 CPU 활용률을 높입니다.
- **효율적인 메모리 사용**: 사용자에 대한 반응 속도를 향상시키고, 프로그램의 일부만 적재하여 실행할 수 있도록 지원합니다(예: 페이징, 세그멘테이션).

### 1.2. 주소 바인딩(Address Binding)

주소 바인딩은 프로그램의 코드와 데이터에 실제 메모리 주소를 부여하는 과정, 즉 논리적 주소를 물리적 주소로 사상(Mapping)하는 것을 의미합니다.

- **논리적 주소(Logical Address)**: 프로그램 내에서 사용되는 변수나 명령어의 상대적 위치 주소입니다.
- **물리적 주소(Physical Address)**: 프로그램이 메모리에 적재될 때 부여받는 실제 주소입니다.
- **재배치 레지스터(Relocation Register)**: MMU(Memory Management Unit) 내에 있으며, 논리적 주소에 더해져 물리적 주소를 생성하는 기준 주소값을 저장합니다. 이를 통해 프로그램의 동적 적재가 가능해집니다.

#### 바인딩 시점

주소 바인딩은 프로그램 처리 과정의 여러 시점에서 발생할 수 있습니다.

|   |   |   |
|---|---|---|
|바인딩 시점|설명|특징|
|**컴파일 시간**|프로그래머나 컴파일러가 절대 주소를 가진 코드를 생성합니다.|프로그램의 메모리 위치가 고정되어 유연성이 떨어집니다.|
|**적재 시간**|컴파일러는 재배치 가능한 코드를 생성하고, 프로그램을 메모리에 적재할 때 실제 주소가 결정됩니다.|프로그램 위치가 변경될 경우 재적재가 필요합니다.|
|**수행 시간**|프로그램이 실행되는 도중에도 메모리 내 위치를 이동할 수 있습니다.|하드웨어(MMU) 지원이 필요하며, 대부분의 현대 운영체제에서 사용하는 방식입니다.|

## 2. 사용자 프로그램 처리 기법

운영체제는 제한된 메모리를 효율적으로 사용하기 위해 다음과 같은 고급 처리 기법을 사용합니다.

### 2.1. 동적 적재 (Dynamic Loading)

전체 프로그램을 한 번에 메모리에 올리는 대신, 주 프로그램만 먼저 적재하고 나머지 루틴들은 **호출될 때** 비로소 메모리에 적재하는 방식입니다. 사용되지 않는 루틴은 메모리를 차지하지 않으므로 실제 필요한 부분만 적재되어 메모리 공간을 매우 효율적으로 사용할 수 있습니다.

### 2.2. 동적 연결 (Dynamic Linking)

프로그램과 라이브러리 파일의 연결을 실행 시점까지 지연시키는 기법입니다.

- **정적 연결 (Static Linking)**: 컴파일 시 라이브러리 코드가 실행 파일에 포함되어 파일 크기가 커지고 메모리 낭비가 발생합니다.
- **동적 연결 (Dynamic Linking)**: 실행 시에 라이브러리가 연결되므로, 여러 프로그램이 메모리 내의 동일한 라이브러리 코드를 공유할 수 있어 효율적입니다.

### 2.3. 중첩 (Overlays)

사용 가능한 메모리 크기보다 큰 프로그램을 실행하기 위한 기법입니다. 프로그램의 코드 중 동시에 실행되지 않는 부분들이 시간적으로 메모리 공간을 나누어 사용하도록 하여, 적은 메모리로도 큰 프로그램을 실행할 수 있게 합니다.

### 2.4. 스와핑 (Swapping)

실행 중인 프로세스들의 전체 크기가 실제 주기억장치 용량보다 클 경우, 특정 프로세스를 일시적으로 보조기억장치(Backing Store)로 내보내고(Swap Out), 필요 시 다시 주기억장치로 가져오는(Swap In) 과정입니다. 이를 통해 제한된 메모리 공간을 여러 프로세스가 공유할 수 있으며, 이 작업은 운영체제의 **중기 스케줄러(Swapper)**가 담당합니다.

## 3. 주기억장치 할당 기법

### 3.1. 연속 할당 (Contiguous Allocation)

프로세스에 메모리 내의 연속된 단일 공간을 할당하는 방식입니다.

- **단일 프로그래밍**: 메모리에 항상 하나의 프로그램만 적재되는 가장 단순한 방식으로, 메모리 낭비가 심합니다. 운영체제 보호를 위해 경계 레지스터가 필요합니다.
- **다중 프로그래밍 (고정 분할)**: 주기억장치를 여러 개의 동일한 크기(또는 다른 고정 크기)의 분할로 나누고 각 분할에 프로세스를 할당합니다. 할당된 공간보다 작은 프로세스가 적재되면 남는 공간이 낭비되는 **내부 단편화**가 발생합니다.
- **다중 프로그래밍 (가변 분할)**: 각 프로세스가 요청하는 크기에 맞춰 동적으로 메모리 공간을 할당합니다. 프로세스가 종료되고 남은 작은 공간들이 흩어져 있어, 총 가용 공간은 충분함에도 불구하고 큰 프로세스를 적재하지 못하는 **외부 단편화**가 발생할 수 있습니다.

#### 가변 분할 배치 전략

새로운 프로세스를 어느 가용 공간(Hole)에 배치할지 결정하는 전략입니다.

|   |   |   |   |
|---|---|---|---|
|전략|설명|장점|단점|
|**최초 적합 (First-Fit)**|적재 가능한 첫 번째 가용 공간에 할당합니다.|탐색 시간이 짧아 배치 결정이 빠릅니다.|사용되지 않는 작은 가용 공간이 누적될 수 있습니다.|
|**최적 적합 (Best-Fit)**|적재 가능한 가용 공간 중 크기가 가장 근접한(가장 작은) 공간에 할당합니다.|가용 공간을 효율적으로 사용할 수 있습니다.|할당 후 매우 작은 가용 공간이 생성되며, 전체 리스트를 검색해야 할 수 있습니다.|
|**최악 적합 (Worst-Fit)**|적재 가능한 가용 공간 중 가장 큰 공간에 할당합니다.|할당 후 남는 공간이 커서 다른 큰 프로그램이 사용 가능할 수 있습니다.|큰 프로그램을 위한 가용 공간이 빠르게 소모될 수 있습니다.|

### 3.2. 단편화 문제와 해결 방안

**단편화(Fragmentation)**는 메모리 공간이 작은 조각으로 나뉘어 사용되지 못하고 낭비되는 현상입니다.

- **내부 단편화 (Internal Fragmentation)**: 할당된 공간 내에서 사용되지 않고 남는 부분 (고정 분할에서 발생).
- **외부 단편화 (External Fragmentation)**: 가용 공간들이 연속적이지 않아 총량은 충분하지만 실제 할당은 불가능한 상태 (가변 분할에서 발생).

#### 외부 단편화 해결 방안

1. **통합 (Coalescing)**: 인접한 가용 공간들을 하나로 합쳐 더 큰 가용 공간으로 만듭니다.
2. **압축 (Compaction)**: 사용 중인 메모리 영역을 한쪽으로 이동시켜 흩어져 있는 가용 공간들을 하나의 큰 덩어리로 만듭니다. 프로세스 이동 비용이 많이 듭니다.

### 3.3. 비연속 할당 (Non-contiguous Allocation)

하나의 프로그램을 여러 부분으로 나누어 메모리의 비연속적인 공간에 분산하여 적재하는 방식입니다. 이는 연속 할당의 외부 단편화 문제를 근본적으로 해결합니다.

#### 페이징 (Paging)

- **개념**: 프로그램을 동일한 고정 크기의 **페이지(Page)**로 분할하고, 물리 메모리는 페이지와 동일한 크기의 **프레임(Frame)**으로 관리합니다.
- **동작**: **페이지 테이블**을 사용하여 각 논리적 페이지가 어느 물리적 프레임에 저장되었는지 매핑합니다.
- **장점**: 외부 단편화가 발생하지 않으며, 압축이 필요 없습니다.
- **단점**: 마지막 페이지에서 소량의 내부 단편화가 발생할 수 있으며, 페이지 테이블 관리를 위한 오버헤드가 존재합니다.

#### 세그멘테이션 (Segmentation)

- **개념**: 프로그램을 논리적 의미 단위(예: 함수, 배열, 스택)인 가변 크기의 **세그먼트(Segment)**로 분할합니다.
- **동작**: 컴파일러가 프로그램을 세그먼트로 분할하며, 각 세그먼트의 시작 주소와 크기 정보를 통해 관리됩니다.
- **특징**: 페이징과 달리 프로그래머가 인식하는 논리적 단위로 분할되므로 공유와 보호가 용이합니다. 하지만 가변 크기 할당으로 인해 **외부 단편화** 문제가 다시 발생할 수 있습니다.