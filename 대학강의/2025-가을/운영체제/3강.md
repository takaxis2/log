# 컴퓨터 시스템 구조 분석

## 요약

본 문서는 컴퓨터 시스템의 핵심 동작 원리, 입출력 구조, 그리고 다양한 입출력 방식을 종합적으로 분석한다. 컴퓨터 시스템은 전원 인가 시 부트스트랩 프로그램을 통해 운영체제 커널을 주기억장치에 적재하는 것으로 기동되며, 이후 모든 동작은 하드웨어 '인터럽트'와 소프트웨어 '트랩'이라는 이벤트 기반으로 처리된다. 운영체제는 이러한 이벤트 발생 시 현재 작업을 중단하고 정해진 루틴을 실행한 뒤 원래 작업으로 복귀하는 방식으로 시스템을 제어한다.

입출력(I/O)은 CPU의 직접적인 개입 없이 장치 제어기와 드라이버를 통해 CPU 연산과 병렬적으로 수행되는 구조를 가진다. I/O 방식은 CPU가 모든 과정을 직접 처리하는 비효율적인 '직접 입출력'에서, DMA(Direct Memory Access)나 '입출력 채널'과 같은 전용 프로세서를 사용하여 CPU의 부담을 최소화하는 '간접 입출력'으로 발전했다. DMA는 CPU의 개입 없이 메모리와 장치 간 데이터 전송을 가능하게 하며, 입출력 채널은 한 단계 더 나아가 독립적인 프로세서로서 복수의 I/O 작업을 자율적으로 관리한다. 이러한 간접 입출력 방식은 다중 프로그래밍 시스템의 효율을 극대화하는 기반 기술이다.

결론적으로, 인터럽트 기반의 이벤트 처리 모델과 CPU로부터 독립된 고성능 간접 입출력 구조의 이해는 운영체제가 어떻게 하드웨어 자원을 효율적으로 관리하고 동시성 높은 컴퓨팅 환경을 제공하는지를 파악하는 데 필수적이다.

--------------------------------------------------------------------------------

## 1. 컴퓨터 시스템의 기본 동작 원리

컴퓨터 시스템의 운영은 정해진 기동 절차를 거쳐 시작되며, 이후 발생하는 모든 상황은 이벤트(Event)로 간주되어 운영체제에 의해 처리된다.

### 1.1. 시스템 기동 (부팅) 프로세스

컴퓨터 시스템은 전원이 인가되거나 리셋 신호를 받으면 다음과 같은 순서로 기동된다. 이 과정을 '부팅'이라 칭한다.

1. **부트스트랩 프로그램 실행**: ROM(Read-Only Memory)에 저장된 부트스트랩(Bootstrap) 프로그램(PC 환경에서는 BIOS)이 가장 먼저 실행된다.
2. **하드웨어 초기화**: 부트스트랩 프로그램은 시스템에 연결된 모든 하드웨어 장치를 점검하고 초기화한다.
3. **운영체제 커널 적재**: 디스크와 같은 보조기억장치에 저장된 운영체제의 핵심 부분인 커널(Kernel)을 주기억장치(RAM)로 불러온다.
4. **커널 실행 및 프로세스 생성**: 커널이 실행되면 시스템 운영에 필요한 첫 번째 프로세스(예: Unix의 'init' 프로세스)를 생성하고 실행한다. 이 초기 프로세스는 필요에 따라 다른 사용자 및 시스템 프로세스들을 생성한다.
5. **이벤트 대기**: 시스템 초기화가 완료되면, 운영체제는 사용자나 하드웨어로부터의 이벤트 발생을 기다리는 대기 상태에 들어간다.

### 1.2. 이벤트 기반 동작: 인터럽트와 트랩

시스템 기동 후 모든 작업은 이벤트 발생과 처리를 통해 이루어진다. 이벤트는 크게 하드웨어 인터럽트와 소프트웨어 트랩으로 나뉜다.

- **하드웨어 인터럽트 (Hardware Interrupt)**: 하드웨어 장치가 CPU의 주의를 필요로 할 때 발생하는 신호이다.
    - **예시**: 키보드 입력, 마우스 움직임, 프린터의 출력 완료, 디스크 읽기/쓰기 완료 등.
- **소프트웨어 트랩 (Software Trap / Trap)**: 소프트웨어 실행 중에 발생하는 이벤트로, 의도적인 경우와 오류로 인한 경우로 나뉜다.
    - **시스템 호출 (System Call)**: 사용자 프로그램이 운영체제의 특정 기능(예: 파일 열기, 메모리 할당)을 요청하기 위해 의도적으로 발생시키는 트랩. PC에서는 '소프트웨어 인터럽트'라고도 불린다.
    - **예외 (Exception)**: 프로그램 수행 중 발생하는 오류 상황. (예: 0으로 나누기, 허용되지 않은 메모리 영역 접근).

이러한 이벤트가 발생하면 운영체제는 다음과 같은 **인터럽트 처리 루틴**을 통해 상황을 처리한다.

1. **상태 보관**: 현재 실행 중이던 작업(프로세스)을 즉시 멈추고, 재개를 위해 현재의 상태(레지스터 값, 프로그램 카운터 등)를 스택과 같은 특정 공간에 저장한다.
2. **원인 분석**: 발생한 인터럽트의 종류를 식별한다.
3. **처리 루틴 실행**: '인터럽트 벡터'를 참조하여 해당 인터럽트에 맞는 서비스 루틴(Interrupt Service Routine)을 찾아 실행한다.
4. **상태 복원 및 작업 재개**: 인터럽트 처리가 완료되면, 보관했던 이전 작업의 상태를 복원하여 중단되었던 지점부터 실행을 계속한다.

## 2. 입출력(I/O) 구조와 동작

효율적인 입출력 처리는 시스템 전체 성능에 지대한 영향을 미친다. 현대 컴퓨터는 CPU와 I/O 장치가 독립적으로 동작하는 구조를 채택하고 있다.

### 2.1. I/O 시스템 구성 요소

- **장치 제어기 (Device Controller)**: 각 입출력 장치(디스크, 키보드 등)를 제어하는 하드웨어 모듈이다. 데이터 전송을 위한 로컬 버퍼(임시 저장 공간)를 내장하고 있다.
- **장치 드라이버 (Device Driver)**: 운영체제의 일부로서, 특정 장치 제어기를 제어하는 소프트웨어이다. 응용 프로그램과 하드웨어 사이의 인터페이스 역할을 한다.
- **동시 실행**: CPU의 연산 작업과 입출력 장치의 데이터 전송 작업은 동시에 진행될 수 있다. CPU는 주기억장치와 장치 제어기의 로컬 버퍼 간 데이터 이동에만 관여할 수 있다.
- **완료 통보**: 장치 제어기는 입출력 작업이 완료되면 CPU에게 인터럽트를 발생시켜 작업 완료를 알린다.

### 2.2. I/O 수행 절차

프로세스가 입출력을 요청하면 다음과 같은 단계적 절차를 거쳐 처리된다.

1. **프로세스의 I/O 요청**: 프로그램이 입출력 명령을 실행한다.
2. **운영체제의 요청 접수**: 운영체제는 해당 요청을 받아 적절한 장치 드라이버에게 전달한다.
3. **장치 드라이버의 요청 전달**: 장치 드라이버는 장치 제어기의 레지스터에 필요한 명령을 설정하여 입출력을 요청한다.
4. **실제 I/O 발생**: 장치 제어기는 물리적 장치를 구동하여 데이터를 읽거나 쓴 후, 그 결과를 자신의 로컬 버퍼에 저장한다.
5. **제어기의 완료 통보 (인터럽트)**: 작업이 완료되면 장치 제어기가 CPU에 인터럽트를 보낸다.
6. **드라이버의 완료 보고**: 인터럽트를 받은 장치 드라이버는 운영체제에게 I/O 완료를 보고한다.
7. **운영체제의 프로세스 통보**: 운영체제는 최종적으로 I/O를 요청했던 프로세스에게 작업이 완료되었음을 알린다.

## 3. 입출력(I/O) 방식의 분류 및 심층 분석

입출력 방식은 CPU의 개입 정도와 동작 방식에 따라 다양하게 분류되며, 시스템 효율성을 결정하는 핵심 요소이다.

### 3.1. 컴퓨터 입출력 방식에 따른 구분

#### 3.1.1. 직접 입출력 (Direct I/O)

CPU가 프로그램 수행 중 입출력 명령을 만나면, 다른 작업을 하지 않고 직접 입출력 과정을 전부 책임지는 방식이다.

- **특징**: CPU는 장치 상태 플래그를 지속적으로 확인('폴링')하며 입출력이 끝날 때까지 대기한다.
- **단점**: 입출력이 진행되는 동안 CPU가 다른 유용한 작업을 할 수 없어 자원 낭비가 매우 심하고 시스템 전체의 처리 효율이 낮아진다.

#### 3.1.2. 간접 입출력 (Indirect I/O)

CPU가 직접 입출력을 수행하지 않고, DMA(Direct Memory Access) 제어기나 입출력 채널(I/O Channel)과 같은 전용 하드웨어에 위임하는 방식이다.

- **특징**: CPU는 입출력 명령만 내린 후 즉시 다른 프로그램을 수행한다. 입출력이 완료되면 전용 하드웨어가 인터럽트를 통해 CPU에게 알린다.
- **장점**: CPU가 입출력 대기 시간 없이 다른 작업을 처리할 수 있어 다중 프로그래밍 환경에서 시스템의 처리율(Throughput)을 획기적으로 향상시킨다.

### 3.2. 주요 간접 I/O 기술

#### 3.2.1. DMA (Direct Memory Access)

DMA는 CPU의 도움 없이 장치 제어기가 직접 주기억장치와 데이터를 주고받을 수 있도록 하는 기술이다.

- **동작 원리**:
    1. CPU는 DMA 제어기에게 전송할 데이터의 주기억장치 시작 주소, 데이터 블록의 크기 등을 설정하고 I/O를 명령한다.
    2. DMA 제어기는 CPU와 독립적으로 장치와 주기억장치 간에 데이터 블록을 직접 전송한다.
    3. 이때 DMA는 주기억장치 버스 사용 권한을 CPU로부터 잠시 '훔쳐서(Cycle Steal)' 사용한다.
    4. 전송이 완료되면 DMA 제어기는 CPU에 인터럽트를 발생시켜 완료를 보고한다.
- **효과**: 워드나 바이트 단위가 아닌 블록 단위의 데이터 전송에 대한 CPU의 부담을 없애준다.

#### 3.2.2. 입출력 채널 (I/O Channel)

입출력 채널은 DMA보다 한 단계 더 발전한 형태로, 그 자체가 하나의 프로세서처럼 동작하는 정교한 입출력 전용 프로세서(PPU, Peripheral Processing Unit)이다.

- **특징**: 채널은 자신만의 명령어 세트를 가지며, CPU로부터 입출력 프로그램의 시작 위치만 전달받으면 스스로 프로그램을 실행하여 복잡한 입출력 작업을 자율적으로 처리한다.
- **종류**:
    - **선택(Selector) 채널**: 디스크와 같은 고속 장치와 한 번에 하나씩 연결하여 데이터를 전송한다.
    - **멀티플렉서(Multiplexer) 채널**: 터미널, 프린터 등 여러 저속 장치를 동시에 연결하여 시분할 방식으로 처리한다.
    - **블록 멀티플렉서(Block Multiplexer) 채널**: 테이프와 같이 블록 단위로 데이터를 전송하는 다수의 장치를 동시에 처리한다.

### 3.3. 하드웨어 특성에 따른 구분

- **폴링(Polling) 방식**: CPU가 주기적으로 모든 입출력 장치의 상태를 순차적으로 검사하여 서비스 요청이 있는지 확인하는 방식이다. 구조는 간단하지만 CPU 시간을 낭비하여 비효율적이다. 직접 입출력 방식에서 주로 사용된다.
- **인터럽트(Interrupt) 방식**: 입출력 장치가 CPU의 도움이 필요할 때만 신호를 보내는 방식이다. CPU가 다른 작업을 하다가 필요할 때만 개입하므로 매우 효율적이다. 대부분의 현대 시스템에서 사용된다.

### 3.4. 동작 방법에 따른 분류

- **동기식(Synchronous) 입출력**: 프로세스가 입출력 요청을 한 후, 해당 입출력이 완료될 때까지 대기(block)하는 방식이다. 프로그래밍은 간단하지만, 입출력 대기 시간 동안 프로세스가 멈춰있어 시스템 효율이 저하된다.
- **비동기식(Asynchronous) 입출력**: 프로세스가 입출력 요청 후 완료를 기다리지 않고 즉시 자신의 다음 작업을 계속 수행하는 방식이다. 입출력 완료는 나중에 운영체제가 별도의 방법(콜백, 신호 등)으로 통지한다. 동시에 여러 작업을 처리할 수 있어 시스템 효율은 높지만, 프로그램 구현이 복잡해진다.

## 4. 인터럽트 메커니즘 상세

### 4.1. 인터럽트 유형

인터럽트는 발생 원인에 따라 다음과 같이 분류된다.

|   |   |   |
|---|---|---|
|구분|주요 유형|설명 및 예시|
|**외부 인터럽트**|전원 이상, 기계 착오, 외부 신호, 입출력(I/O)|시스템 외부 요인으로 발생. (예: 정전, 하드웨어 오류, 타이머 만료, I/O 완료)|
|**내부 인터럽트**|잘못된 명령, 프로그램 검사 (오류)|프로그램 실행 중 내부적인 오류로 발생. **트랩(Trap)**이라고도 함. (예: 0으로 나누기, 보호된 메모리 접근, 스택 오버플로우)|
|**소프트웨어 인터럽트**|슈퍼바이저 호출 (SVC)|사용자 프로그램이 OS 서비스를 요청하기 위해 의도적으로 발생시키는 명령어.|

### 4.2. 인터럽트 우선순위

여러 인터럽트가 동시에 발생할 경우, 시스템 안정성과 직결되는 긴급한 인터럽트부터 처리하기 위해 우선순위가 정해져 있다. 일반적인 우선순위는 다음과 같다.

1. **전원 이상** (가장 높음)
2. **기계 착오**
3. **외부 신호**
4. **입출력(I/O)**
5. **명령어 오류**
6. **프로그램 검사**
7. **SVC (슈퍼바이저 호출)** (가장 낮음)