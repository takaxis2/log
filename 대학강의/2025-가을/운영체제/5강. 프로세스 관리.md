

## 핵심 요약

본 문서는 운영체제의 핵심 기능인 프로세스 관리에 대한 포괄적인 분석을 제공합니다. 프로세스는 실행 중인 프로그램을 의미하며, 운영체제는 이러한 프로세스들을 효율적으로 관리하여 시스템 성능을 최적화합니다.

주요 내용은 세 가지 핵심 주제로 구성됩니다. 첫째, **프로세스의 개념**에서는 프로세스의 정의, 상태(생성, 준비, 실행, 대기, 완료), 그리고 프로세스의 모든 정보를 담고 있는 자료 구조인 프로세스 제어 블록(PCB)에 대해 설명합니다. 둘째, **프로세스 스케줄링**은 다수의 프로세스 중에서 어떤 프로세스에 CPU를 할당할지 결정하는 정책으로, 시스템의 처리량 극대화와 응답 시간 최소화를 목표로 합니다. 스케줄링은 장기, 중기, 단기 스케줄러에 의해 계층적으로 수행됩니다. 셋째, **프로세스 간 통신(IPC)**은 독립된 프로세스들이 데이터를 교환하고 동기화할 수 있도록 하는 기법으로, 주로 공유 메모리 방식과 메시지 전달 방식으로 구현됩니다.

--------------------------------------------------------------------------------

## 1. 프로세스 개념 (Process Concept)

프로세스는 단순히 디스크에 저장된 수동적(Passive)인 프로그램 파일을 넘어, 프로그램 카운터를 가지고 능동적(Active)으로 실행되는 개체를 의미합니다. 운영체제는 이러한 프로세스들의 생성, 삭제, 동기화, 통신, 교착상태 처리 등을 포함하는 포괄적인 프로세스 관리를 수행합니다.

### 1.1. 프로세스의 정의 및 구성 요소

- **정의**: 현재 실행 중이거나 실행 가능한 상태로, 고유한 프로세스 제어 블록(PCB)을 가진 프로그램을 지칭합니다. 지정된 결과를 얻기 위한 일련의 계통적 동작이며, 비동기적 행위로도 정의됩니다.
- **구성 요소**: 프로세스는 단순히 코드뿐만 아니라 실행에 필요한 다양한 정보를 포함합니다.
    - **기억장치 문맥 (Memory Context)**: 프로그램 코드를 담는 코드 세그먼트, 전역 변수를 포함하는 데이터 세그먼트, 그리고 서브루틴 매개변수나 복귀 주소 등 임시 자료를 저장하는 실행 스택으로 구성됩니다.
    - **프로세서 문맥 (Processor Context)**: 상태 워드나 각종 레지스터들의 값을 포함합니다.
    - **프로세스 속성**:
        - **이름(번호)**: 프로세스 생성 시 할당되는 내부적인 고유 번호.
        - **우선순위**: CPU 할당 스케줄링에 사용되는 값.
        - **권한**: 정보 보호 및 수행 가능 연산 지정을 위한 값.

### 1.2. 순차 프로세스와 병행 프로세스

- **순차 프로세스 (Sequential Process)**: 한 시점에서 단 하나의 명령어만 순차적으로 실행되는 가장 기본적인 프로세스 모델입니다.
- **병행 프로세스 (Concurrent Process)**: 두 개 이상의 프로세스가 동시에 존재하는 환경에서의 실행 형태로, 다음과 같이 분류됩니다.
    - **형태 1 (순차 실행)**: 한 프로세스(p)의 실행이 완전히 종료된 후 다음 프로세스(q)가 실행됩니다.
    - **형태 2 (모조 병렬성, Pseudo Parallelism)**: 단일 프로세서 환경에서 두 프로세스(p, q)가 짧은 시간 간격으로 번갈아 가며 실행됩니다. 특정 순간에는 하나의 프로세스만 실행되지만, 전체적으로는 동시에 실행되는 것처럼 보입니다.
    - **형태 3 (실제 병렬성, Real Parallelism)**: 두 개 이상의 분리된 프로세서가 존재하여 두 프로세스(p, q)의 명령어 스트림이 시간적으로 중첩되어 동시에 실행됩니다.

### 1.3. 프로세스 상태와 전이

프로세스는 생성부터 소멸까지 여러 상태를 거치며, 특정 사건에 의해 상태가 변화합니다. 한 시점에는 하나의 프로세스만 '실행' 상태에 있을 수 있습니다.

|   |   |
|---|---|
|상태|설명|
|**생성 (New)**|작업이 시스템에 제출되어 디스크의 스풀 공간에 수록된 상태입니다.|
|**준비 (Ready)**|CPU를 할당받을 수 있는 상태로, 자신의 차례를 기다리는 상태입니다.|
|**실행 (Running)**|CPU를 차지하고 명령어를 수행하고 있는 상태입니다.|
|**대기 (Blocked)**|입출력(I/O) 처리 등 특정 사건이 완료되기를 기다리는 상태입니다.|
|**교착 (Deadlock)**|결코 일어날 수 없는 사건의 발생을 기다리는 상태입니다.|
|**완료 (Terminated)**|주어진 시간 내에 실행을 완전히 종료한 상태로, 곧 시스템에서 제거됩니다.|

**주요 상태 전이 과정:**

- **디스패치 (Dispatch)**: 준비 상태의 프로세스 중 하나가 선택되어 CPU를 할당받아 실행 상태로 전환됩니다. (준비 → 실행)
- **할당시간 초과 (Time Runout)**: CPU 할당 시간을 모두 사용한 프로세스가 다시 준비 상태로 전환됩니다. (실행 → 준비)
- **대기 (Block)**: 실행 중인 프로세스가 입출력 명령을 만나면 스스로 CPU를 양도하고 대기 상태로 전환됩니다. (실행 → 대기)
- **깨움 (Wake Up)**: 대기 상태에서 기다리던 입출력 작업이 완료되면 준비 상태로 전환되어 다시 CPU 할당을 기다립니다. (대기 → 준비)

### 1.4. 프로세스 제어 블록 (Process Control Block, PCB)

PCB는 운영체제가 각 프로세스를 식별하고 관리하는 데 필요한 모든 핵심 정보를 담고 있는 자료 구조 테이블입니다. 프로세스 생성 시 함께 만들어지며, 프로세스 종료 시 삭제됩니다.

**PCB에 포함되는 주요 정보:**

- **프로세스 상태**: 생성, 준비, 실행, 대기 등 현재 프로세스의 상태
- **프로세스 고유 이름 (Identifier)**: 프로세스를 식별하는 고유 번호
- **프로그램 카운터 (Program Counter)**: 다음에 실행할 명령어의 주소
- **CPU 레지스터 정보**: 누산기, 인덱스 레지스터 등 인터럽트 시 보관해야 할 레지스터 값
- **프로세스 우선순위**: 스케줄링 시 사용될 우선순위
- **메모리 관리 정보**: 경계 레지스터, 페이지 테이블 등 프로세스가 할당된 메모리 영역 정보
- **계정 정보**: CPU 사용 시간, 계정 번호 등
- **입출력 상태 정보**: 프로세스에 할당된 입출력 장치, 열린 파일 목록 등

## 2. 프로세스 스케줄링 (Process Scheduling)

스케줄링은 컴퓨터 시스템의 성능을 향상시키기 위해 여러 프로세스의 자원 사용 순서를 결정하는 정책입니다.

### 2.1. 스케줄링의 목적

- **공정성**: 모든 프로세스에 공평한 기회 제공
- **처리량 극대화**: 단위 시간당 완료되는 작업의 수를 최대화
- **응답 시간 최소화**: 요청 발생 후 첫 응답이 오기까지의 시간을 최소화
- **자원 사용 균형**: CPU, I/O 장치 등 자원을 균형 있게 활용
- **무한 연기 배제**: 특정 프로세스의 실행이 무한히 지연되지 않도록 보장

### 2.2. 스케줄링의 수준별 분류

|   |   |   |   |
|---|---|---|---|
|수준|별칭|주요 역할|실행 빈도|
|**상위 수준**|장기 스케줄러 (Long-term) / 작업 스케줄러|어떤 작업을 시스템에 받아들일지 결정하여 다중 프로그래밍의 정도를 제어합니다.|낮음 (느림)|
|**중위 수준**|중기 스케줄러 (Intermediate-level)|프로세스를 일시 보류(suspend)시키거나 다시 활성화(resume)하여 시스템의 단기적 부하를 조절합니다.|중간|
|**하위 수준**|단기 스케줄러 (Short-term) / CPU 스케줄러 / 디스패처|준비 큐에 있는 프로세스 중 어떤 프로세스에 CPU를 할당할지 결정합니다.|높음 (매우 빠름)|

### 2.3. 스케줄링 큐 (Scheduling Queues)

프로세스는 실행되는 동안 목적에 따라 여러 큐를 오가게 됩니다.

- **작업 큐 (Job Queue)**: 시스템 내의 모든 프로세스 집합.
- **준비 큐 (Ready Queue)**: 주기억장치에 적재되어 CPU 할당을 기다리는 프로세스들의 집합. 일반적으로 연결 리스트로 구현됩니다.
- **장치 큐 (Device Queue)**: 특정 입출력 장치의 처리가 완료되기를 기다리는 프로세스들의 집합.

프로세스는 준비 큐에서 CPU를 할당받아 실행되다가, 입출력 요청 시 해당 장치 큐로 이동하여 대기하고, 작업 완료 후 다시 준비 큐로 돌아오는 과정을 반복합니다.

### 2.4. 문맥 교환 (Context Switch)

문맥 교환은 현재 실행 중인 프로세스의 상태 정보(문맥)를 해당 프로세스의 PCB에 저장하고, 다음에 실행할 프로세스의 문맥을 PCB에서 복원하여 CPU를 전환하는 과정입니다. 이 과정은 시스템에 부담을 주는 순수 오버헤드이며, 소요 시간은 하드웨어 성능(메모리 속도, 레지스터 수 등)에 따라 달라집니다.

## 3. 프로세스 간 통신 (Inter-Process Communication, IPC)

IPC는 동일한 주소 공간을 공유하지 않는 독립적인 프로세스들이 서로 통신하고 동기화할 수 있도록 운영체제가 제공하는 메커니즘입니다.

### 3.1. 통신 방식의 종류

- **공유 메모리 (Shared Memory)**: 통신할 프로세스들이 특정 메모리 공간을 공유하며, 응용 프로그램 작성자가 직접 통신 기능을 구현하는 방식입니다.
- **메시지 전달 (Message Passing)**: 운영체제가 `Send(메시지)`와 `Receive(메시지)` 같은 통신 연산을 제공하여, 데이터 공유 없이 프로세스 간 통신을 중개하는 방식입니다.

### 3.2. 직접 통신 (Direct Communication)

메시지를 송수신하는 각 프로세스가 통신 상대의 이름을 명시적으로 지정하는 방식입니다.

- **연산 예시**: `Send(P, Message)`는 P 프로세스에게 메시지를 전송하고, `Receive(Q, Message)`는 Q 프로세스로부터 메시지를 수신합니다.
- **특징**:
    - 통신하는 프로세스 쌍 사이에 자동으로 연결이 설정됩니다.
    - 통신을 위해 서로의 신원을 알아야 합니다.
    - 하나의 연결은 정확히 두 개의 프로세스만 관련됩니다.

### 3.3. 간접 통신 (Indirect Communication)

메시지를 메일박스(Mailbox) 또는 포트(Port)라는 매개체를 통해 송수신하는 방식입니다.

- **연산 예시**: `Send(A, Message)`는 A 메일박스로 메시지를 보내고, `Receive(A, Message)`는 A 메일박스로부터 메시지를 받습니다.
- **특징**:
    - 프로세스들이 공동의 메일박스를 공유하는 경우에만 통신이 가능합니다.
    - 하나의 연결(메일박스)에 두 개 이상의 프로세스가 참여할 수 있습니다.
    - 통신 상대의 신원을 직접 알 필요가 없습니다.