
## 요약 (Executive Summary)

본 문서는 운영체제의 핵심 개념인 프로세스 동기화에 대해 심층적으로 분석한다. 현대 컴퓨터 시스템은 다수의 프로세스를 병행 처리하므로, 공유 자원에 대한 접근을 조율하는 동기화 메커니즘은 데이터의 일관성을 유지하고 시스템의 안정성을 보장하는 데 필수적이다.

핵심 문제는 여러 프로세스가 동시에 공유 자원에 접근하려 할 때 발생하는 **경쟁 조건(Race Condition)**이며, 이를 해결하기 위한 핵심 영역이 바로 **임계구역(Critical Section)**이다. 임계구역 문제에 대한 해결책은 반드시 **상호 배제(Mutual Exclusion)**, **진행(Progress)**, **한계 대기(Bounded Waiting)**라는 세 가지 조건을 충족해야 한다.

본 문서는 임계구역 문제를 해결하기 위한 다양한 접근법을 제시한다. 초기 해결책인 소프트웨어적 지원(예: 빵집 알고리즘)과 하드웨어적 지원(예: 인터럽트 금지, TestAndSet 명령어)부터, 이들의 단점인 바쁜 대기(Busy Waiting) 문제를 개선한 고급 동기화 도구인 **세마포어(Semaphore)**와 **모니터(Monitor)**에 이르기까지 상세히 다룬다. 마지막으로, 공유 메모리 방식과 대조되는 **메시지 전달(Message Passing)** 방식의 프로세스 간 통신 방법을 소개하며 동기화에 대한 포괄적인 이해를 제공한다.

--------------------------------------------------------------------------------

## I. 서론: 프로세스 동기화의 필요성

### A. 현대 컴퓨터 시스템과 병행 처리

현대 컴퓨터 시스템은 다중 프로그램화된 운영체제를 기반으로 여러 프로세스를 병행 처리하여 생산성을 극대화한다. 이 과정에서 프로세스들은 파일이나 논리적 주소 공간(스레드) 등 자원을 공유하며 협력해야 할 필요가 생기며, 이로 인해 데이터 불일치(Data Inconsistency) 문제가 발생할 수 있다. 따라서 프로세스 간의 협조와 **동기화(Synchronization)**는 필수적이다.

### B. 병행 프로세스의 주요 문제

병행 프로세스 환경에서는 다음과 같은 네 가지 주요 문제를 고려해야 한다.

- **결정성 (Determinacy):** 프로세스들의 상대적인 실행 속도와 무관하게 주어진 초기값에 대해 항상 동일한 결과를 내는가?
- **상호 배제 (Mutual Exclusion):** 공유 자원에 대해 한 번에 하나의 프로세스만 접근이 허용되는가?
- **동기화 (Synchronization):** 한 프로세스의 진행이 다른 프로세스의 진행에 의존하는가?
- **교착 (Deadlock):** 여러 프로세스가 서로 점유한 자원을 무한정 기다리며 아무도 진행하지 못하는 상태에 빠지는가?

### C. 경쟁 조건 (Race Condition)

경쟁 조건이란 둘 이상의 프로세스가 공유 메모리(기억장치)에 동시에 접근하여 읽고 쓰는 과정에서, 어떤 프로세스가 언제 실행되느냐에 따라 결과가 달라지는 상황을 의미한다. 대부분의 경우 올바른 결과가 나오지만, 특정 실행 순서에서는 예측 불가능한 오류를 초래할 수 있다. 이러한 경쟁 조건을 방지하기 위해 반드시 병행 프로세스들을 동기화해야 한다.

## II. 임계구역 문제와 해결 방안

### A. 임계구역(Critical Section)의 정의

임계구역이란 프로세스가 공유 변수 변경, 테이블 갱신, 파일 쓰기 등 공유 자원에 접근하는 코드 영역을 의미한다. 시스템에 존재하는 여러 프로세스가 공유 자원을 사용하기 위해 경쟁할 때, 이 임계구역에 대해서는 반드시 상호 배제가 보장되어야 한다.

한 프로세스가 임계구역에서 실행 중일 때는 다른 어떤 프로세스도 해당 임계구역에 진입할 수 없도록 보장하는 것이 **임계구역 문제(The Critical Section Problem)**의 핵심이다. 이를 위해 각 프로세스는 임계구역 진입 전 허가를 요청하는 **진입구역(Entry Section)**과 진입 후 코드를 실행하는 **임계구역(Critical Section)**, 실행 후 상태를 정리하는 **출구구역(Exit Section)**, 그리고 나머지 코드인 **잔류구역(Reminder Section)**으로 구성된 프로토콜을 따라야 한다.

### B. 임계구역 문제 해결의 요구 조건

임계구역 문제에 대한 해결책은 다음 세 가지 조건을 반드시 만족해야 한다.

1. **상호 배제 (Mutual Exclusion):** 한 프로세스가 자신의 임계구역에서 실행 중이라면, 다른 어떤 프로세스도 그들의 임계구역에서 실행될 수 없다.
2. **진행 (Progress):** 임계구역에서 실행 중인 프로세스가 없고, 임계구역에 진입하려는 프로세스가 있다면, 다음에 진입할 프로세스를 결정하는 것을 무한정 연기해서는 안 된다.
3. **한계 대기 (Bounded Waiting):** 한 프로세스가 임계구역 진입을 요청한 후, 다른 프로세스들이 해당 임계구역에 진입하도록 허용되는 횟수에 한계가 있어야 한다. 이는 특정 프로세스가 무한정 기다리는 **기아 상태(Starvation)**를 방지한다.

### C. 해결 방법론

상호 배제를 실현하기 위한 방법은 크게 소프트웨어적 지원과 하드웨어적 지원으로 나뉜다.

|   |   |   |
|---|---|---|
|구분|방법|설명|
|**소프트웨어적 지원**|N개 프로세스 해결 (예: 빵집 알고리즘)|프로세스가 임계구역 진입 전 번호표를 받는다. 낮은 번호를 가진 프로세스가 먼저 진입하며, 번호가 같을 경우 고유한 프로세스 번호로 우선순위를 결정한다.|
|**하드웨어적 지원**|인터럽트 금지|**단일 프로세서 시스템**에서 임계구역 실행 중 인터럽트를 비활성화하여 문맥 교환을 막는다. 다중 프로세서 시스템에서는 효과가 없으며 시스템 효율을 저하시킬 수 있다.|
||특수 기계 명령어|원자적으로(중단 없이) 실행되는 `TestAndSet`이나 `Swap` 같은 명령어를 사용한다. 다중 프로세서에서도 적용 가능하지만, 자원이 가용해질 때까지 CPU를 소모하며 반복 확인하는 **바쁜 대기(Busy-waiting)**를 유발하고, 교착 및 기아 상태를 야기할 수 있다.|

## III. 고급 동기화 도구

바쁜 대기 문제 등을 해결하기 위해 더 정교한 동기화 도구들이 개발되었다.

### A. 세마포어 (Semaphore)

E.J. Dijkstra가 제안한 세마포어는 동기화 문제를 해결하는 강력한 도구로, 정수 값을 갖는 변수와 이 변수에 접근하는 원자적 연산으로 구성된다. 은행 금고(공유 자원)와 열쇠(자원 사용권) 비유를 통해 이해할 수 있듯이, 운영체제는 세마포어를 통해 자원 사용권을 관리한다.

- **핵심 연산**
    - **초기화 (Initialize):** 세마포어 변수 값을 음이 아닌 정수로 설정한다.
    - **Wait() 연산 (P 연산):** 세마포어 값을 1 감소시킨다. 만약 결과가 음수가 되면, 해당 프로세스는 대기 큐로 이동하여 블록(block)된다. 이는 바쁜 대기를 방지한다.
    - **Signal() 연산 (V 연산):** 세마포어 값을 1 증가시킨다. 만약 결과가 0 이하이면(즉, 대기 중인 프로세스가 있다면), 대기 큐에 있던 프로세스 중 하나를 깨워(wakeup) 준비 상태로 만든다.
- **세마포어 값의 의미**
    - **양수:** 현재 사용 가능한 자원의 수
    - **음수:** 자원을 기다리며 대기 큐에 블록되어 있는 프로세스의 수 (절댓값)
- **문제점**
    - **교착상태 (Deadlock):** 두 개 이상의 프로세스가 서로 상대방이 점유한 자원을 기다리며 무한 대기하는 상황이 발생할 수 있다.
    - **기아상태 (Starvation):** 프로세스가 세마포어 대기 큐에서 무한정 대기할 수 있다.

### B. 모니터 (Monitor)

모니터는 공유 자원과 해당 자원에 접근하는 프로시저들을 하나로 묶은 병행성 구조이다. 모니터는 자체적으로 상호 배제를 보장하므로, **한 순간에 단 하나의 프로세스만이 모니터 내부에 진입하여 활성화될 수 있다.** 프로세스는 자원을 사용하기 위해 반드시 모니터가 제공하는 진입부를 호출해야 한다. 이는 세마포어보다 더 높은 수준의 추상화를 제공하여 프로그래머의 실수를 줄여준다.

### C. 메시지 전달 (Message Passing)

메시지 전달은 공유 메모리를 사용하지 않고 프로세스 간에 통신하고 동기화하는 방식이다. `Send`와 `Receive`라는 두 가지 기본 연산을 사용한다.

|   |   |
|---|---|
|방식|설명|
|**직접 통신**|`Send(수신자, 메시지)`와 `Receive(송신자, 메시지)`를 사용하여 송신자와 수신자를 명확히 지정한다. 통신하는 프로세스들은 서로의 신원을 알고 있어야 한다.|
|**간접 통신**|공유 **우편함(Mailbox)**을 매개로 메시지를 주고받는다. `Send(우편함, 메시지)`와 `Receive(우편함, 메시지)`를 사용하며, 여러 프로세스가 하나의 우편함을 통해 통신할 수 있다.|
|**원격 프로시저 호출 (RPC)**|분산 시스템 환경에서 사용된다. 한 컴퓨터의 프로세스가 다른 컴퓨터에 있는 프로세스의 프로시저를 마치 로컬 프로시저처럼 호출한다. 호출한 프로세스는 원격지에서 응답이 올 때까지 블록된다.|

## IV. 요약 및 결론

병행 프로세스 환경에서 공유 자원에 대한 안전한 접근을 보장하는 것은 운영체제의 핵심 과제이다. **임계구역** 문제는 이러한 과제를 해결하기 위한 출발점이며, **상호 배제**, **진행**, **한계 대기**라는 명확한 해결 조건을 가진다.

초기의 소프트웨어 및 하드웨어 기반 해결책들은 바쁜 대기와 같은 비효율성을 내포하고 있었다. 이를 개선하기 위해 제안된 **세마포어**와 **모니터**는 프로세스를 블록 및 재개시키는 방식으로 CPU 낭비를 줄이고 보다 체계적인 동기화를 가능하게 했다. 또한, **메시지 전달**은 공유 메모리에 의존하지 않는 대안적인 통신 및 동기화 모델을 제공한다.

이러한 동기화 메커니즘들은 결정성, 상호 배제, 동기화 문제를 해결하고 교착 상태를 예방하는 데 필수적이며, 현대 운영체제의 안정성과 신뢰성을 뒷받침하는 기반 기술이다.