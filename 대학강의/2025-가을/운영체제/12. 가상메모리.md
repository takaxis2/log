
## 요약

본 문서는 운영체제의 핵심 기능인 가상 메모리(Virtual Memory)의 개념, 관리 기법, 그리고 성능 저하 문제인 쓰레싱(Thrashing)에 대해 종합적으로 분석한다. 가상 메모리는 실제 물리적 주기억장치의 용량보다 큰 프로세스도 실행할 수 있도록 보조기억장치를 활용하는 기법으로, 사용자에게는 훨씬 큰 메모리 공간이 있는 것처럼 보이게 한다.

가상 메모리의 핵심 이점은 다중 프로그래밍의 정도를 높여 CPU 이용률과 처리율을 향상시키고, 스왑(Swap) 입출력 양을 줄여 프로그램 실행 속도를 개선하며, 프로그래머가 오버레이(Overlay)와 같은 복잡한 메모리 관리 기법을 직접 다룰 필요가 없게 한다는 점이다.

이러한 가상 메모리를 효율적으로 관리하기 위해 운영체제는 세 가지 핵심 정책을 사용한다.

1. **반입 정책(Fetch Policy):** 언제 페이지를 메모리로 가져올지 결정한다. (예: 요구 반입, 예상 반입)
2. **배치 정책(Placement Policy):** 가져온 페이지를 메모리의 어느 위치에 둘지 결정한다.
3. **교체 정책(Replacement Policy):** 메모리가 가득 찼을 때 어떤 페이지를 내보낼지 결정한다.

특히 페이지 교체 정책은 시스템 성능에 직접적인 영향을 미치며, 선입선출(FIFO), 최적(Optimal), LRU(Least Recently Used), NUR(Not Used Recently) 등 다양한 알고리즘이 존재한다.

마지막으로, 각 프로세스에 충분한 메모리 프레임이 할당되지 않았을 때 발생하는 '쓰레싱' 현상을 다룬다. 쓰레싱은 과도한 페이지 교체로 인해 실제 프로세스 실행보다 입출력에 더 많은 시간을 소모하는 심각한 성능 저하 상태이다. 이를 방지하기 위해 워킹 세트(Working Set) 모델을 유지하고 지역성(Locality) 원리를 활용하여 다중 프로그래밍의 정도를 조절하는 것이 중요하다.

--------------------------------------------------------------------------------

## 1. 가상 메모리의 개념과 필요성

### 배경: 물리적 메모리의 한계

전통적인 방식에서는 프로세스 전체가 메모리에 적재되어야 실행이 가능했다. 이로 인해 프로세스의 크기가 실제 메모리 크기보다 클 경우 프로그램을 실행할 수 없는 문제가 발생했다. 이를 해결하기 위해 프로그래머가 직접 프로그램의 일부만 메모리에 올리는 **중첩(Overlay)**이나 **동적 적재(Dynamic Loading)** 기법을 사용해야 했으며, 이는 프로그래머의 부담을 가중시키는 원인이었다.

### 부분 적재 방식과 가상 메모리의 도입

프로그램 실행 시 모든 코드가 동시에 필요한 것은 아니라는 관찰에서 **부분 적재 방식**이 고안되었다. 오류 처리 코드나 도움말 기능처럼 특정 조건에서만 사용되는 부분을 제외하고, 실행에 필수적인 부분만 메모리에 적재(페이지 단위)하여 프로그램을 수행하는 것이다.

이 개념을 시스템 차원에서 자동화한 것이 **가상 메모리(Virtual Memory)**이다. 가상 메모리는 사용자의 주소 공간을 여러 부분(페이지 또는 세그먼트)으로 나누고, 실행 시 필요한 부분만 주기억장치에 적재하여, 사용자에게 주기억장치 용량보다 훨씬 더 큰 가상 공간을 제공하는 시스템이다. 프로세스의 전체 주소 공간은 주기억장치와 보조기억장치(디스크)에 걸쳐 설정된다.

### 가상 메모리의 핵심 이점

부분 적재를 기반으로 한 가상 메모리 시스템은 다음과 같은 중요한 이점을 제공한다.

- **메모리 크기 제약 극복:** 프로그램의 크기가 실제 물리 메모리 크기에 제한받지 않는다.
- **CPU 이용률 및 처리율 향상:** 더 많은 프로세스를 동시에 주기억장치에 유지할 수 있어 다중 프로그래밍의 정도가 높아지고, 이는 CPU 이용률과 시스템 전체의 처리율을 높인다.
- **빠른 실행 속도:** 프로세스 실행에 필요한 스왑(Swap) 입출력의 양이 줄어들어 각 프로그램이 더 빠르게 실행될 수 있다.
- **프로그래머 부담 감소:** 과거 프로그래머가 직접 처리해야 했던 오버레이 기법과 같은 복잡한 메모리 관리 부담을 운영체제가 담당한다.

--------------------------------------------------------------------------------

## 2. 가상 메모리 관리 기법

가상 메모리 시스템의 효율성은 디스크와 메모리 사이의 페이지 이동을 얼마나 잘 관리하느냐에 달려있다. 이를 위해 운영체제는 다음 세 가지 정책을 사용한다.

### 1) 반입 정책 (Fetch Policy): 언제 적재할 것인가?

페이지나 세그먼트를 보조기억장치에서 주기억장치로 언제 옮길지 결정하는 정책이다.

|   |   |   |
|---|---|---|
|구분|요구 반입 (Demand Fetch)|예상 반입 (Anticipatory Fetch)|
|**개념**|실행 중인 프로세스가 특정 페이지를 참조할 때 해당 페이지를 적재한다.|프로세스가 앞으로 참조할 페이지를 미리 예측하여 선제적으로 적재한다.|
|**장점**|어떤 페이지를 옮길지 결정하는 오버헤드가 적다.|예측이 성공하면 프로세스 실행 시간이 크게 감소한다.|
|**단점**|페이지를 할당받기 위해 대기하는 시간이 길다.|페이지 참조를 예측하고 결정하는 데 따르는 오버헤드가 크다.|

### 2) 배치 정책 (Placement Policy): 어디에 적재할 것인가?

가져온 페이지나 세그먼트를 주기억장치의 어느 위치에 적재할지 결정하는 정책이다.

- **페이징 시스템:** 모든 페이지 프레임이 동일한 크기이므로 사용 가능한 어떤 프레임에 적재해도 무관하다. 따라서 배치 정책이 거의 필요 없다.
- **세그먼테이션 시스템:** 가변 분할 방식과 유사하게, 필요한 크기의 공간을 할당해야 한다. 이때 다음과 같은 기법이 사용될 수 있다.
    - **최초 적합 (First-Fit):** 적재 가능한 공간 중 가장 먼저 발견되는 공간에 할당한다.
    - **최적 적합 (Best-Fit):** 적재 가능한 공간 중 프로그램 크기와 가장 비슷한 크기의 공간에 할당한다.
    - **최악 적합 (Worst-Fit):** 적재 가능한 공간 중 가장 큰 공간에 할당한다.

### 3) 교체 정책 (Replacement Policy): 무엇을 제거할 것인가?

주기억장치가 모두 사용 중일 때, 새로운 페이지를 적재하기 위해 기존 페이지 중 어느 것을 제거할지 선택하는 정책이다. 시스템 성능에 가장 큰 영향을 미치는 정책으로, 다양한 알고리즘이 존재한다.

--------------------------------------------------------------------------------

## 3. 주요 페이지 교체 알고리즘 분석

### 1) 선입선출 (FIFO: First-In, First-Out)

- **개념:** 주기억장치에 가장 먼저 들어온 페이지를 가장 먼저 교체한다.
- **장점:** 구현이 간단하고 이해하기 쉽다.
- **단점:** 중요한 페이지가 단지 오래 있었다는 이유만으로 교체될 수 있다. **'FIFO의 모순' (Belady's Anomaly)** 현상이 발생할 수 있는데, 이는 페이지 프레임 수를 늘렸음에도 불구하고 페이지 부재(Page Fault) 횟수가 오히려 증가하는 비정상적인 상황을 의미한다.

### 2) 최적 페이지 교체 (OPT: Optimal Page Replacement)

- **개념:** 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체한다.
- **장점:** 최소의 페이지 부재율을 보장하며, FIFO의 모순이 발생하지 않는다. 모든 알고리즘 성능 평가의 기준이 된다.
- **단점:** 프로세스가 앞으로 참조할 페이지 순서를 미리 알아야 하므로 실제 시스템에서는 구현이 불가능한 비현실적인 알고리즘이다.

### 3) LRU (Least Recently Used)

- **개념:** 가장 오랫동안 사용되지 않은 페이지를 교체한다. 이는 '과거에 오랫동안 사용되지 않았다면 미래에도 사용되지 않을 것'이라는 지역성(Locality) 원리에 기반한다.
- **장점:** 최적 교체 알고리즘에 근접한 좋은 성능을 보이며, FIFO의 모순이 발생하지 않는다.
- **단점:** 각 페이지의 참조 시간을 기록하고 비교해야 하므로 시간적 오버헤드가 발생하며, 하드웨어 지원 없이는 구현이 복잡하다.

### 4) LFU (Least Frequently Used)

- **개념:** 참조된 횟수(사용 빈도)가 가장 적은 페이지를 교체한다.
- **장점:** FIFO의 모순이 발생하지 않는다.
- **단점:** 참조 횟수만 고려하므로, 최근에 적재되었지만 아직 참조 횟수가 적은 페이지가 바로 교체될 수 있다.

### 5) NUR (Not Used Recently)

- **개념:** LRU의 복잡성을 줄인 근사 알고리즘으로, 최근에 사용되지 않은 페이지를 교체한다. 각 페이지마다 **참조 비트(Reference bit)**와 **변형 비트(Modified bit)**를 사용한다.
    - **참조 비트:** 페이지가 참조되면 1, 아니면 0.
    - **변형 비트:** 페이지 내용이 변경(write)되면 1, 아니면 0.
- **동작:** 교체 시, 두 비트의 조합을 확인하여 우선순위가 가장 낮은 페이지를 선택한다. 일반적으로 (참조=0, 변형=0)인 페이지가 가장 먼저 교체 대상이 된다.

|   |   |   |   |
|---|---|---|---|
|참조 비트|변형 비트|페이지 상태|교체 우선순위|
|0|0|참조되지 않고, 변형되지 않음|가장 높음 (먼저 교체됨)|
|0|1|참조되지 않았지만, 변형됨|높음|
|1|0|참조되었지만, 변형되지 않음|낮음|
|1|1|참조되었고, 변형됨|가장 낮음 (마지막에 교체됨)|

--------------------------------------------------------------------------------

## 4. 쓰레싱 (Thrashing): 가상 메모리의 성능 저하 문제

### 쓰레싱의 정의와 현상

**쓰레싱**이란 프로세스가 실행에 필요한 최소한의 페이지 프레임도 할당받지 못해 페이지 부재가 연속적으로 발생하고, 결과적으로 CPU가 실제 연산을 수행하는 시간보다 페이지를 교체(Swapping)하는 데 더 많은 시간을 소모하는 현상이다. 이 상태에 빠지면 시스템의 CPU 이용률이 급격히 떨어지고 전체 성능이 심각하게 저하된다.

### 발생 원인

쓰레싱은 주로 다음과 같은 악순환 구조로 인해 발생한다.

1. 운영체제는 CPU 이용률이 낮아지면 시스템에 유휴 자원이 있다고 판단하여 새로운 프로세스를 시스템에 추가해 다중 프로그래밍의 정도를 높인다.
2. 새로운 프로세스가 메모리를 차지하면서 기존 프로세스들에게 할당된 페이지 프레임 수가 줄어든다.
3. 프레임이 부족해진 각 프로세스에서 페이지 부재가 빈번하게 발생한다.
4. 페이지 교체를 위한 디스크 입출력이 증가하면서 준비 큐(Ready Queue)의 프로세스가 줄어들고, CPU 이용률은 더욱 저하된다.
5. 운영체제는 다시 CPU 이용률이 낮다고 판단하여 또 다른 프로세스를 추가하며 악순환이 반복된다.

### 방지 대책

쓰레싱을 방지하기 위해서는 각 프로세스가 원활히 실행될 수 있는 최소한의 메모리 공간을 보장해야 한다.

1. **다중 프로그래밍 정도 조절:** CPU 이용률이 특정 임계점 이하로 떨어지면, 새로운 프로세스를 추가하는 대신 일부 프로세스를 비활성화하여 각 프로세스가 충분한 프레임을 확보하도록 다중 프로그래밍의 정도를 낮춘다.
2. **워킹 세트 (Working Set) 모델 유지:**
    - **워킹 세트**란 특정 시간 간격(Window Size) 동안 한 프로세스가 참조한 페이지들의 집합이다.
    - 프로세스가 효율적으로 실행되기 위해서는 자신의 워킹 세트 전체가 주기억장치에 유지되어야 한다.
    - 운영체제는 각 프로세스의 워킹 세트를 추적하고, 이를 유지할 만큼의 프레임을 할당해야 한다.
3. **지역성 (Locality) 원리 활용:**
    - **지역성**이란 프로세스가 실행되는 동안 메모리의 특정 영역을 집중적으로 참조하는 경향을 의미하며, 이는 워킹 세트 모델의 이론적 근거가 된다.
    - **시간 지역성 (Temporal Locality):** 최근에 참조된 메모리 위치는 가까운 미래에 다시 참조될 가능성이 높다. (예: 반복문, 서브루틴)
    - **공간 지역성 (Spatial Locality):** 특정 메모리 위치가 참조되면 그 주변의 메모리 위치들도 곧 참조될 가능성이 높다. (예: 배열, 순차적인 코드 실행)
    - 운영체제는 이 지역성을 고려하여 페이지를 관리함으로써 페이지 부재율을 낮추고 쓰레싱을 방지할 수 있다.