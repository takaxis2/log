
### 핵심 요약

CPU 스케줄링은 다중 프로그래밍 운영체제 환경에서 시스템의 생산성과 CPU 이용률을 극대화하기 위한 핵심적인 자원 관리 정책입니다. 그 목적은 CPU가 유휴 상태에 빠지지 않도록 항상 실행할 프로세스를 준비시켜, CPU 이용률과 처리량을 최대화하고, 평균 대기 시간, 응답 시간, 총 처리 시간을 최소화하는 데 있습니다.

스케줄링 알고리즘은 크게 실행 중인 프로세스를 중단시킬 수 없는 **비선점형(Non-preemptive)**과 중단시킬 수 있는 **선점형(Preemptive)**으로 분류됩니다. 비선점형 방식에는 FCFS, SJF, 우선순위 스케줄링이 있으며, 공정성과 예측 가능성이란 장점이 있지만 긴급한 작업에 대한 대응이 어렵습니다. 선점형 방식에는 라운드 로빈(RR), SRT, 다단계 큐 등이 있으며, 대화식 시스템에 적합하고 빠른 응답 시간을 제공하지만 문맥 교환에 따른 오버헤드가 발생할 수 있습니다.

현대 운영체제는 다양한 특성을 가진 프로세스들을 효율적으로 관리하기 위해 **다단계 큐(MLQ)**나 프로세스가 큐 간에 이동할 수 있는 **다단계 피드백 큐(MFQ)**와 같은 복합적인 알고리즘을 사용합니다. 최적의 알고리즘 선택은 특정 시스템의 요구사항(예: 최대 응답 시간 보장, 처리율 극대화)에 따라 결정되며, 결정적 모델링, 큐잉 모델, 시뮬레이션 등의 방법을 통해 그 성능을 평가합니다.

--------------------------------------------------------------------------------

### 1. CPU 스케줄링의 기본 개념

#### 1.1. 정의 및 목표

CPU 스케줄링은 다중 프로그래밍 운영체제의 근간을 이루는 개념으로, 운영체제가 여러 프로세스 간에 CPU를 교환하여 컴퓨터의 생산성을 높이는 정책입니다. 핵심 목표는 항상 CPU를 실행 상태로 유지하여 CPU 이용률을 최대화하는 것입니다. 이를 통해 동시에 여러 프로그램을 메모리에 적재하고 CPU를 분할 사용함으로써 짧은 시간에 더 많은 작업을 수행할 수 있습니다.

#### 1.2. 프로세스 실행 주기

프로세스 실행은 CPU 실행(CPU 버스트)과 입출력 대기(I/O 버스트) 사이클의 반복으로 구성됩니다. 프로세스는 이 두 상태를 교대로 수행하며, 그 특성에 따라 다음과 같이 분류됩니다.

- **CPU-bound Process:** 대부분의 시간을 연산에 소비하며 긴 CPU 버스트를 가집니다.
- **I/O-bound Process:** 대부분의 시간을 입출력에 소비하며 짧은 CPU 버스트를 가집니다.

#### 1.3. 스케줄링 발생 시점

CPU 스케줄링은 다음과 같은 프로세스 상태 전환 시점에 필요합니다.

1. **실행(Running) → 대기(Waiting):** 프로세스가 입출력 요청 시
2. **실행(Running) → 준비(Ready):** 인터럽트 발생 시
3. **대기(Waiting) → 준비(Ready):** 입출력 종료 시
4. **종료(Terminated):** 프로세스 종료 시

#### 1.4. 스케줄링 방식 분류

스케줄링 방식은 실행 중인 프로세스의 중단 가능 여부에 따라 선점형과 비선점형으로 나뉩니다.

|   |   |   |
|---|---|---|
|구분|선점(Preemptive) 스케줄링|비선점(Non-preemptive) 스케줄링|
|**개념**|현재 수행 중인 프로세스가 다른 프로세스(예: 더 높은 우선순위)에게 CPU를 빼앗길 수 있음.|현재 수행 중인 프로세스는 I/O 요청이나 종료 시까지 CPU를 독점적으로 사용함.|
|**장점**|우선순위가 높은 프로세스나 짧은 작업을 먼저 처리하여 빠른 응답 시간을 보장함.|모든 프로세스에 대한 요구를 공정하게 처리하며, 응답 시간 예측이 용이함.|
|**단점**|잦은 문맥 교환으로 인한 오버헤드가 큼.|짧은 작업이 긴 작업 뒤에서 무한정 기다릴 수 있음.|
|**적합 시스템**|대화식 시분할 시스템|일괄 처리 시스템|
|**대표 알고리즘**|RR, SRT, 다단계 큐(MLQ), 다단계 피드백 큐(MFQ)|FCFS, SJF, 우선순위|

### 2. 스케줄링 성능 평가 기준

최적의 스케줄링 알고리즘을 선택하기 위해 사용되는 주요 성능 기준은 다음과 같습니다.

|   |   |   |
|---|---|---|
|기준|설명|목표|
|**CPU 이용률 (Utilization)**|단위 시간당 CPU가 유휴 상태 없이 활동하는 시간의 비율 (보통 40% ~ 90%).|**최대화**|
|**처리량 (Throughput)**|단위 시간당 완료된 프로세스의 수.|**최대화**|
|**총 처리 시간 (Turnaround Time)**|프로세스가 시스템에 제출된 후 완료될 때까지 걸린 총 시간.|**최소화**|
|**대기 시간 (Waiting Time)**|프로세스가 준비 큐(Ready Queue)에서 CPU 할당을 기다린 시간의 총합.|**최소화**|
|**응답 시간 (Response Time)**|사용자가 요청을 보낸 후 첫 번째 응답이 나올 때까지의 시간.|**최소화**|

### 3. 주요 스케줄링 알고리즘 분석

#### 3.1. 선입선처리 (FCFS: First-Come, First-Served)

- **방식:** 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형 방식. FIFO(First-In, First-Out) 큐로 구현됩니다.
- **특징:** 가장 간단하고 공평한 알고리즘입니다.
- **문제점:** CPU 버스트가 긴 프로세스가 먼저 도착하면 다른 모든 프로세스가 기다려야 하는 **호위 효과(Convoy Effect)**가 발생하여 평균 대기 시간이 길어질 수 있습니다. 대화식 시스템에는 부적합합니다.

#### 3.2. 최소 작업 우선 (SJF: Shortest-Job-First)

- **방식:** 다음 CPU 버스트 길이가 가장 짧은 프로세스에게 CPU를 할당합니다. 비선점형(SJF)과 선점형(Shortest-Remaining-Time-First, SRT)으로 나뉩니다.
- **특징:** 평균 대기 시간을 최소화하는 최적의 알고리즘입니다.
- **문제점:** 다음 CPU 버스트 시간을 예측하는 것이 불가능하여 단기 스케줄링에 적용하기 어렵습니다.

#### 3.3. 우선순위 스케줄링 (Priority Scheduling)

- **방식:** 각 프로세스에 부여된 우선순위에 따라 CPU를 할당합니다. 우선순위가 같으면 FCFS를 적용합니다.
- **문제점:** 우선순위가 낮은 프로세스가 영원히 실행되지 못하는 **기아(Starvation) 상태** 또는 **무한 대기(Indefinite Blocking)** 현상이 발생할 수 있습니다.
- **해결책:** **에이징(Aging)** 기법을 사용하여 오래 대기한 프로세스의 우선순위를 점진적으로 높여줍니다.

#### 3.4. 라운드 로빈 (RR: Round-Robin)

- **방식:** FCFS에 선점 개념을 도입한 것으로, 각 프로세스는 **시간 할당량(Time Quantum)**이라는 제한된 시간 동안만 CPU를 사용하고, 시간이 만료되면 준비 큐의 맨 뒤로 이동합니다.
- **특징:** 시분할 시스템에 효과적이며, 응답 속도가 빠릅니다.
- **고려사항:** 성능이 시간 할당량 크기에 크게 좌우됩니다.
    - 할당량이 너무 크면 FCFS와 유사해집니다.
    - 할당량이 너무 작으면 잦은 문맥 교환으로 오버헤드가 증가합니다.

#### 3.5. 다단계 큐 스케줄링 (MLQ: Multilevel Queue)

- **방식:** 준비 큐를 여러 개의 독립적인 큐(예: 시스템 작업, 대화형 작업, 일괄 처리 작업 큐)로 분할합니다. 각 큐는 자신만의 스케줄링 알고리즘(예: 대화형 큐는 RR, 일괄 처리 큐는 FCFS)을 가집니다.
- **특징:** 프로세스 유형에 따라 다른 스케줄링 정책을 적용할 수 있습니다. 일반적으로 큐 간에는 고정된 우선순위에 기반한 선점 스케줄링이 사용됩니다.

#### 3.6. 다단계 피드백 큐 스케줄링 (MFQ: Multilevel Feedback Queue)

- **방식:** 다단계 큐와 유사하지만, 프로세스가 큐 사이를 이동할 수 있습니다. CPU를 오래 사용하는 프로세스는 낮은 우선순위 큐로 이동하고, I/O 대기로 CPU를 양도한 프로세스는 높은 우선순위 큐로 이동할 수 있습니다.
- **특징:** 짧은 작업과 입출력 위주 작업에 우선권을 부여하여 CPU와 I/O 장치의 효율을 높입니다. 기아 상태를 방지하는 가장 유연하고 복잡한 알고리즘 중 하나입니다.

### 4. 알고리즘 특성 종합 비교

|   |   |   |
|---|---|---|
|알고리즘|방식 구분|핵심 특징|
|**FCFS**|비선점|간단하고 공평하나, 호위 효과 발생 가능. 대화형에 부적합.|
|**SJF**|비선점|평균 대기 시간이 가장 짧지만, CPU 버스트 예측이 어려움.|
|**SRT**|선점|SJF의 선점형 버전. 이론적으로 가장 작은 평균 대기 시간을 보장.|
|**우선순위**|비선점/선점|우선순위가 높은 순서대로 처리. 기아(Starvation) 문제 발생 가능.|
|**라운드 로빈(RR)**|선점|시분할 방식에 효과적. 시간 할당량 크기에 성능이 좌우됨.|
|**다단계 큐(MLQ)**|선점|작업 그룹별로 다른 큐와 스케줄링 정책을 적용.|
|**다단계 피드백 큐(MFQ)**|선점|큐 간 이동을 허용하여 CPU와 I/O 효율을 높임. 유연성이 높음.|

### 5. 다중 프로세서 및 알고리즘 평가

#### 5.1. 다중 프로세서 스케줄링

여러 개의 CPU를 사용하는 시스템에서는 스케줄링 문제가 더욱 복잡해집니다. 주요 접근 방식은 다음과 같습니다.

- **비대칭 다중 프로세싱 (Asymmetric):** 하나의 주 프로세서가 모든 스케줄링 결정과 I/O 처리를 담당하고, 다른 프로세서들은 사용자 코드만 실행합니다. 구현이 간단하지만 주 프로세서에 병목 현상이 발생할 수 있습니다.
- **대칭 다중 프로세싱 (Symmetric, SMP):** 각 프로세서가 독립적으로 스케줄링을 수행합니다. 모든 프로세스가 공동의 준비 큐를 공유하거나, 각 프로세서가 별도의 준비 큐를 가질 수 있습니다.

#### 5.2. 알고리즘 평가 방법

특정 시스템에 가장 적합한 알고리즘을 선택하기 위한 평가 방법은 다음과 같습니다.

- **결정적 모델링 (Deterministic Modeling):** 미리 정의된 특정 작업 부하에 대해 각 알고리즘의 성능 지표를 계산하여 비교합니다. 결과가 주어진 데이터에만 의존한다는 한계가 있습니다.
- **큐잉 모델 (Queueing Models):** CPU 버스트 분포 등 수학적 가정을 기반으로 시스템을 모델링하고, 대기 시간과 같은 지표를 수학적으로 분석합니다. 가정이 실제와 다를 수 있습니다.
- **시뮬레이션 (Simulation):** 실제 시스템의 동작을 모방하는 프로그램을 작성하여 스케줄링 알고리즘을 평가합니다. 가장 정확한 방법이지만, 구현에 많은 시간과 노력이 요구됩니다.